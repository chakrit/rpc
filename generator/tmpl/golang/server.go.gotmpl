// <auto-generated />
//
// expected import: {{ .ImportPath }}/server
package server

import (
    "bytes"
    "context"
    "encoding/json"
    "io"
    "net/http"

    {{ template "imports" . }}
)

{{  define "handlerType" -}}
    type Handler_{{ .MangledName }} struct {
        Handler {{ .MangledName }}.Interface
    {{  range $child := .Children -}}
        {{ $child.Namespace.Name }} Handler_{{ $child.MangledName }}
    {{  end -}}
    }

    {{  range $child := .Children  }}
        {{ template "handlerType" $child }}
    {{  end -}}
{{- end -}}

{{ template "handlerType" . }}

type Result struct {
    Error   error         `json:"error"`
    Returns []interface{} `json:"returns"`
}

type Server struct {
    options Options
    Handler_{{ .MangledName }}
}

type Options struct {
    Addr      string
    CtxFilter func(req *http.Request, method string) context.Context
    ErrFilter func(req *http.Request, method string, err error) error
    ErrLog    func(req *http.Request, method string, err error)
}

func New(opts *Options) *Server {
    srv := &Server{options: *opts}
    if srv.options.CtxFilter == nil {
        srv.options.CtxFilter = func(req *http.Request, _ string) context.Context {
            return req.Context()
        }
    }
    if srv.options.ErrFilter == nil {
        srv.options.ErrFilter = func(_ *http.Request, _ string, err error) error {
            return err
        }
    }
    return srv
}

func (s *Server) Listen() error {
    return http.ListenAndServe(s.options.Addr, s.HTTPHandler())
}

func (s *Server) HTTPHandler() http.Handler {
    mux := http.NewServeMux()
    s.register_{{ .MangledName }}(mux, s.Handler_{{ .MangledName }})
    return mux
}

{{- define "registerFunc" -}}
    {{ $pkg := . }}

    func (s *Server) register_{{ .MangledName }}(
        mux *http.ServeMux,
        handler Handler_{{ .MangledName }},
    ) *http.ServeMux {

    {{  range $rpc := .Namespace.RPCs -}}
        mux.HandleFunc("/{{ $pkg.RPCPath }}/{{ $rpc.Name }}", func(resp http.ResponseWriter, req *http.Request) {
            var (
                err error
                ctx context.Context
            )

            ctx = s.options.CtxFilter(req, "{{ $pkg.RPCPath }}/{{ $rpc.Name }}")
            req = req.WithContext(ctx)

            resp.Header().Set("Content-Type", "application/json")

            {{  range $index, $type := $rpc.InputTypes  }}
                var arg{{ $index }} {{ asReference (resolveAbs $pkg $type) }}
            {{- end -}}
            {{- if (len $rpc.InputTypes)  }}
                args := [{{ len $rpc.InputTypes }}]interface{}{
                {{- range $index, $_ := $rpc.InputTypes  }}
                    &arg{{ $index }},
                {{- end  }}
                }

                if req.Body != nil {
                    if err := json.NewDecoder(req.Body).Decode(&args); err != nil {
                        resp.WriteHeader(400)
                        renderError(resp, err)
                        return
                    }
                }
            {{- end  }}

            var (
            {{  range $index, $type := $rpc.OutputTypes  }}
                out{{ $index }} {{ asReference (resolveAbs $pkg $type) }}
            {{- end  }}
            )

            {{  range $index, $_ := $rpc.OutputTypes -}}
                out{{ $index }},
            {{- end -}}
            err = handler.Handler.{{ $rpc.Name }}(
                ctx,
            {{- range $index, $_ := $rpc.InputTypes -}}
                arg{{ $index }},
            {{- end -}}
            )

            if err != nil {
                err = s.options.ErrFilter(req, "{{ $pkg.RPCPath }}/{{ $rpc.Name }}", err)
                s.options.ErrLog(req, "{{ $pkg.RPCPath }}/{{ $rpc.Name }}", err)
            }

            result := &Result{
                Error: err,
                Returns: []interface{}{
            {{- range $index, $_ := $rpc.OutputTypes  }}
                out{{ $index }},
            {{- end  }}
                },
            }

            if buf, err := json.Marshal(result); err != nil {
                resp.WriteHeader(500)
                renderError(resp, err)
            } else {
                resp.WriteHeader(200)
                _, _ = io.Copy(resp, bytes.NewBuffer(buf))
            }
        })

    {{  end -}}

    {{  range $child := .Children -}}
        s.register_{{ .MangledName }}(mux, handler.{{ $child.Namespace.Name }})
    {{  end -}}

        return mux
    }

    {{  range $child := .Children -}}
        {{ template "registerFunc" $child }}
    {{  end -}}
{{- end -}}

{{  template "registerFunc" .  }}

func renderError(resp http.ResponseWriter, e error) {
    result := &Result{
        Error: e,
        Returns: nil,
    }

    bytes, err := json.Marshal(result)
    if err != nil {
        _, _ = resp.Write([]byte(`{"error":"json processing error"}`))
    } else {
        _, _ = resp.Write(bytes)
    }
}
