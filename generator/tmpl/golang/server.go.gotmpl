// <auto-generated />
//
// expected import: {{ .ImportPath }}/server
package server

import (
    "net/http"
    "encoding/json"
    {{ template "imports" . }}
)

{{  define "handlerType" -}}
    type Handler_{{ .MangledName }} struct {
        Handler {{ .MangledName }}.Interface
    {{  range $child := .Children -}}
        {{ $child.Namespace.Name }} Handler_{{ $child.MangledName }}
    {{  end -}}
    }

    {{  range $child := .Children  }}
        {{ template "handlerType" $child }}
    {{  end -}}
{{- end -}}

{{ template "handlerType" . }}

type Result struct {
    Error   error         `json:"error"`
    Returns []interface{} `json:"returns"`
}

type Server struct {
    Options
    Handler_{{ .MangledName }}
}

type Options struct {
    Addr string
}

func New(opts *Options) *Server {
    return &Server{Options: *opts}
}

func (s *Server) Listen() error {
    return http.ListenAndServe(s.Options.Addr, s.HTTPHandler())
}

func (s *Server) HTTPHandler() http.Handler {
    mux := http.NewServeMux()
    s.register_{{ .MangledName }}(mux, s.Handler_{{ .MangledName }})
    return mux
}

{{- define "registerFunc" -}}
    {{ $pkg := . }}

    func (s *Server) register_{{ .MangledName }}(
        mux *http.ServeMux,
        handler Handler_{{ .MangledName }},
    ) *http.ServeMux {

    {{  range $rpc := .Namespace.RPCs -}}
        mux.HandleFunc("/{{ $pkg.RPCPath }}/{{ $rpc.Name }}", func(resp http.ResponseWriter, req *http.Request) {
            var err error
            resp.Header().Set("Content-Type", "application/json")

            {{  range $index, $type := $rpc.InputTypes  }}
                var arg{{ $index }} {{ asReference (resolveAbs $pkg $type) }}
            {{- end -}}
            {{- if (len $rpc.InputTypes)  }}
                args := [{{ len $rpc.InputTypes }}]interface{}{
                {{- range $index, $_ := $rpc.InputTypes  }}
                    &arg{{ $index }},
                {{- end  }}
                }

                if req.Body != nil {
                    if err := json.NewDecoder(req.Body).Decode(&args); err != nil {
                        resp.WriteHeader(400)
                        renderError(resp, err)
                        return
                    }
                }
            {{- end  }}

            {{  range $index, $type := $rpc.OutputTypes  }}
                var out{{ $index }} {{ asReference (resolveAbs $pkg $type) }}
            {{- end  }}
            {{  range $index, $_ := $rpc.OutputTypes -}}
                out{{ $index }},
            {{- end -}}
            err = handler.Handler.{{ $rpc.Name }}(
                req.Context(),
            {{- range $index, $_ := $rpc.InputTypes -}}
                arg{{ $index }},
            {{- end -}}
            )
            result := &Result{
                Error: err,
                Returns: []interface{}{
            {{- range $index, $_ := $rpc.OutputTypes  }}
                out{{ $index }},
            {{- end  }}
                },
            }

            bytes, err := json.Marshal(result)
            if err != nil {
                resp.WriteHeader(500)
                renderError(resp, err)
            }

            resp.WriteHeader(200)
            _, _ = resp.Write(bytes)
        })

    {{  end -}}

    {{  range $child := .Children -}}
        s.register_{{ .MangledName }}(mux, handler.{{ $child.Namespace.Name }})
    {{  end -}}

        return mux
    }

    {{  range $child := .Children -}}
        {{ template "registerFunc" $child }}
    {{  end -}}
{{- end -}}

{{  template "registerFunc" .  }}

func renderError(resp http.ResponseWriter, e error) {
    result := &Result{
        Error: e,
        Returns: nil,
    }

    bytes, err := json.Marshal(result)
    if err != nil {
        _, _ = resp.Write([]byte(`{"error":"json processing error"}`))
    } else {
        _, _ = resp.Write(bytes)
    }
}
