// <auto-generated />
//
// expected import: {{ .ImportPath }}/server
package server

import (
    "context"
    "encoding/json"
    "net/http"

    {{ template "imports" . }}
)


{{  define "providerType" -}}
    type Provider_{{ .MangledName }} interface {
        Provide_{{ .MangledName }}() {{ .MangledName }}.Interface

    {{  range $child := .Children -}}
        Provider_{{ $child.MangledName }}
    {{  end -}}
    }

    {{  range $child := .Children -}}
        {{ template "providerType" $child }}
    {{  end -}}
{{- end -}}

{{ template "providerType" . }}

type Result struct {
    Error   error         `json:"error"`
    Returns []interface{} `json:"returns"`
}

type Server struct {
    options Options
    Provider Provider_{{ .MangledName }}
}

type Options struct {
    Addr      string
    CtxFilter func(req *http.Request, method string) context.Context
    ErrFilter func(req *http.Request, method string, err error) error
    ErrLog    func(req *http.Request, method string, err error)
    FormatErr func(err error) string
}

func New(opts *Options) *Server {
    srv := &Server{options: *opts}
    if srv.options.CtxFilter == nil {
        srv.options.CtxFilter = func(req *http.Request, _ string) context.Context {
            return req.Context()
        }
    }
    if srv.options.ErrFilter == nil {
        srv.options.ErrFilter = func(_ *http.Request, _ string, err error) error {
            return err
        }
    }
    return srv
}

func (s *Server) Listen() error {
    return http.ListenAndServe(s.options.Addr, s.HTTPHandler())
}

func (s *Server) HTTPHandler() http.Handler {
    mux := http.NewServeMux()
    s.register_{{ .MangledName }}(mux, s.Provider)
    return mux
}

{{- define "registerFunc" -}}
    {{ $pkg := . }}

    func (s *Server) register_{{ .MangledName }}(
        mux *http.ServeMux,
        provider Provider_{{ .MangledName }},
    ) *http.ServeMux {
        handler := provider.Provide_{{ .MangledName }}()

    {{  range $rpc := .Namespace.RPCs -}}
        mux.HandleFunc("/{{ $pkg.RPCPath }}/{{ $rpc.Name }}", func(resp http.ResponseWriter, req *http.Request) {
            var (
                err error
                ctx context.Context
            )

            ctx = s.options.CtxFilter(req, "{{ $pkg.RPCPath }}/{{ $rpc.Name }}")
            req = req.WithContext(ctx)

            {{  range $index, $type := $rpc.InputTypes  }}
                var arg{{ $index }} {{ asReference (resolveAbs $pkg $type) }}
            {{- end -}}
            {{- if (len $rpc.InputTypes)  }}
                args := [{{ len $rpc.InputTypes }}]interface{}{
                {{- range $index, $_ := $rpc.InputTypes  }}
                    &arg{{ $index }},
                {{- end  }}
                }

                if req.Body != nil {
                    if err := json.NewDecoder(req.Body).Decode(&args); err != nil {
                        renderResult(s.options, resp, 400, &Result{
                            Error: err,
                            Returns: nil,
                        })
                        return
                    }
                }
            {{- end  }}

            var (
            {{  range $index, $type := $rpc.OutputTypes  }}
                out{{ $index }} {{ asReference (resolveAbs $pkg $type) }}
            {{- end  }}
            )

            {{  range $index, $_ := $rpc.OutputTypes -}}
                out{{ $index }},
            {{- end -}}
            err = handler.{{ $rpc.Name }}(
                ctx,
            {{- range $index, $_ := $rpc.InputTypes -}}
                arg{{ $index }},
            {{- end -}}
            )

            result := &Result{}
            if err != nil {
                err = s.options.ErrFilter(req, "{{ $pkg.RPCPath }}/{{ $rpc.Name }}", err)
                s.options.ErrLog(req, "{{ $pkg.RPCPath }}/{{ $rpc.Name }}", err)
                result.Error = err
            } else {
                result.Returns = []interface{}{
                {{- range $index, $_ := $rpc.OutputTypes  }}
                    out{{ $index }},
                {{- end  }}
                }
            }

            renderResult(s.options, resp, 200, result)
        })

    {{  end -}}

    {{  range $child := .Children -}}
        s.register_{{ .MangledName }}(mux, s.Provider)
    {{  end -}}

        return mux
    }

    {{  range $child := .Children -}}
        {{ template "registerFunc" $child }}
    {{  end -}}
{{- end -}}

{{  template "registerFunc" .  }}

func renderResult(options Options, resp http.ResponseWriter, status int, result *Result) {
    resp.Header().Set("Content-Type", "application/json")

    shim := struct{
        Error   *string       `json:"error"`
        Returns []interface{} `json:"returns"`
    }{}

    if result.Error != nil {
        var errstr string
        if options.FormatErr != nil {
            errstr = options.FormatErr(result.Error)
        } else {
            errstr = result.Error.Error()
        }

        shim.Returns, shim.Error = nil, &errstr

    } else {
        shim.Returns, shim.Error = result.Returns, nil
    }

    buf, err := json.Marshal(shim)
    if err != nil {
        resp.WriteHeader(500)
        _, _ = resp.Write([]byte(`{"error":"json processing error","result":null}`))
    } else {
        resp.WriteHeader(status)
        _, _ = resp.Write(buf)
    }
}
