{{- $clientPkg := .ContextPkg -}}
{{- $rootPkg := .DataPkg -}}
// <auto-generated />
// @generated by github.com/chakrit/rpc
//
// expected import: {{ $rootPkg.ImportPath }}/client
package client


import (
    "bytes"
    "context"
    "encoding/json"
    "net/http"
    "time"
    {{ template "imports" $rootPkg }}
)

var (
    _ context.Context = nil
    _ time.Time = time.Time{}
)

{{- define "rpc_receiver" -}}
    {{ $clientPkg := .ContextPkg }}
    {{ $pkg := .DataPkg }}

    // {{ $pkg.ImportPath }}
    var _ {{ $pkg.MangledName }}.Interface = Client_{{ $pkg.MangledName }}{}

    type Client_{{ $pkg.MangledName }} struct {
        *Client
    {{  range $child := $pkg.Children -}}
        {{ pascal $child.Name }} Client_{{ $child.MangledName }}
    {{  end -}}
    }

    func (c *Client_{{ $pkg.MangledName }}) initialize(client *Client) {
        c.Client = client
        {{- range $child := $pkg.Children  }}
            c.{{ pascal $child.Name }} = Client_{{ $child.MangledName }}{}
            c.{{ pascal $child.Name }}.initialize(client)
        {{- end  }}
    }

    {{  range $rpc := $pkg.Namespace.RPCs.SortedByName -}}
        func (c Client_{{ $pkg.MangledName }}) {{ $rpc.Name }}(
            ctx context.Context,
        {{  range $index, $arg := .InputTypes -}}
            arg{{ $index }} {{ asReference $clientPkg (resolve $pkg $arg) }},
        {{  end -}}
        ) (
        {{  range $index, $arg := .OutputTypes -}}
            out{{ $index }} {{ asReference $clientPkg (resolve $pkg $arg) }},
        {{  end -}}
            err error,
        ) {
            payload := []interface{}{
            {{- range $index, $_ := .InputTypes -}}
                arg{{ $index }},
            {{- end -}}
            }

            buf := &bytes.Buffer{}
            if err = json.NewEncoder(buf).Encode(payload); err != nil {
                return
            }

            var req *http.Request
            req, err = http.NewRequest("POST", "http://" + c.Client.Options.Addr + "/{{ $pkg.RPCPath }}/{{ $rpc.Name }}", buf)
            if err != nil {
                return
            }

            req = req.WithContext(ctx)

            var resp *http.Response
            resp, err = c.HTTPClient.Do(req)
            if err != nil {
                return
            }

            returns := [{{ len .OutputTypes }}]interface{}{
        {{- range $index, $_ := .OutputTypes -}}
                &out{{ $index }},
        {{- end -}}
            }
            result := &Result{}
            result.Returns = returns[:]

            if resp.Body != nil {
                defer resp.Body.Close()

                if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
                    return
                }
            }

            if result.Error != nil {
                err = result.Error
            }
            return
        }
    {{  end -}}

    {{- range $child := $pkg.Children -}}
        {{ template "rpc_receiver" (context $clientPkg $child) }}
    {{- end -}}
{{- end -}}{{/* rpc_receiver */}}

{{ template "rpc_receiver" . }}

type Result struct {
	Error   error         `json:"error"`
	Returns []interface{} `json:"returns"`
}

type Client struct {
    Options
    Client_{{ $rootPkg.MangledName }}

    HTTPClient *http.Client
}

type Options struct {
    Addr string
}

func New(opts *Options) *Client {
    client := &Client{
        Options: *opts,
        Client_{{ $rootPkg.MangledName }}: Client_{{ $rootPkg.MangledName }}{},
        HTTPClient: &http.Client{},
    }
    client.Client_{{ $rootPkg.MangledName }}.initialize(client)
    return client
}
