// <auto-generated />
//
// expected import: {{ .ImportPath }}/client
package client

import (
    "bytes"
    "encoding/json"
    "net/http"
    "time"
    {{ template "imports" . }}
)

var _ time.Time = time.Time{}

{{- define "rpc_receiver" -}}
    {{- with $pkg := .  }}
        // {{ $pkg.ImportPath }}
        var _ {{ $pkg.MangledName }}.Interface = Client_{{ $pkg.MangledName }}{}

        type Client_{{ $pkg.MangledName }} struct {
            *Client
        {{  range $child := .Children -}}
            {{ pascal $child.Name }} Client_{{ $child.MangledName }}
        {{  end -}}
        }

        func (c *Client_{{ $pkg.MangledName }}) initialize(client *Client) {
            c.Client = client
            {{- range $child := .Children  }}
                c.{{ pascal $child.Name }} = Client_{{ $child.MangledName }}{}
                c.{{ pascal $child.Name }}.initialize(client)
            {{- end  }}
        }

        {{  range $rpc := .Namespace.RPCs.SortedByName -}}
            func (c Client_{{ $pkg.MangledName }}) {{ $rpc.Name }}(
            {{  range $index, $arg := .InputTypes -}}
                arg{{ $index }} {{ asReference (resolveAbs $pkg $arg) }},
            {{  end -}}
            ) (
            {{  range $index, $arg := .OutputTypes -}}
                out{{ $index }} {{ asReference (resolveAbs $pkg $arg) }},
            {{  end -}}
                err error,
            ) {
                payload := []interface{}{
                {{- range $index, $_ := .InputTypes -}}
                    arg{{ $index }},
                {{- end -}}
                }

                buf := &bytes.Buffer{}
                if err = json.NewEncoder(buf).Encode(payload); err != nil {
                    return
                }

                var req *http.Request
                req, err = http.NewRequest("POST", "http://" + c.Client.Options.Addr + "/{{ $pkg.RPCPath }}/{{ $rpc.Name }}", buf)
                if err != nil {
                    return
                }

                var resp *http.Response
                resp, err = c.HTTPClient.Do(req)
                if err != nil {
                    return
                }

                returns := [{{ len .OutputTypes }}]interface{}{
            {{- range $index, $_ := .OutputTypes -}}
                    &out{{ $index }},
            {{- end -}}
                }
                result := &Result{}
                result.Returns = returns[:]

                if resp.Body != nil {
                    defer resp.Body.Close()

                    if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
                        return
                    }
                }

                if result.Error != nil {
                    err = result.Error
                }
                return
            }

        {{  end -}}
    {{- end -}}

    {{- range $child := .Children -}}
        {{ template "rpc_receiver" $child }}
    {{- end -}}
{{- end -}}{{/* rpc_receiver */}}

{{ template "rpc_receiver" . }}

type Result struct {
	Error   error         `json:"error"`
	Returns []interface{} `json:"returns"`
}

type Client struct {
    Options
    Client_{{ .MangledName }}

    HTTPClient *http.Client
}

type Options struct {
    Addr string
}

func New(opts *Options) *Client {
    client := &Client{
        Options: *opts,
        Client_{{ .MangledName }}: Client_{{ .MangledName }}{},
        HTTPClient: &http.Client{},
    }
    client.Client_{{ .MangledName }}.initialize(client)
    return client
}
