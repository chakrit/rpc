// <auto-generated />
//
// expected import: github.com/chakrit/rpc/examples/server
package server

import (
	"encoding/json"
	"net/http"

	gcr1_examples "github.com/chakrit/rpc/examples"
	gcre2_todo "github.com/chakrit/rpc/examples/todo"
	gcret3_auth "github.com/chakrit/rpc/examples/todo/auth"

	gcret4_system "github.com/chakrit/rpc/examples/todo/system"
)

type Handler_gcr1_examples struct {
	Handler gcr1_examples.Interface
	Todo    Handler_gcre2_todo
}

type Handler_gcre2_todo struct {
	Handler gcre2_todo.Interface
	Auth    Handler_gcret3_auth
	System  Handler_gcret4_system
}

type Handler_gcret3_auth struct {
	Handler gcret3_auth.Interface
}

type Handler_gcret4_system struct {
	Handler gcret4_system.Interface
}

type Result struct {
	Error   error         `json:"error"`
	Returns []interface{} `json:"returns"`
}

type Server struct {
	Options
	Handler_gcr1_examples
}

type Options struct {
	Addr string
}

func New(opts *Options) *Server {
	return &Server{Options: *opts}
}

func (s *Server) Listen() error {
	return http.ListenAndServe(s.Options.Addr, s.HTTPHandler())
}

func (s *Server) HTTPHandler() http.Handler {
	mux := http.NewServeMux()
	s.register_gcr1_examples(mux, s.Handler_gcr1_examples)
	return mux
}

func (s *Server) register_gcr1_examples(
	mux *http.ServeMux,
	handler Handler_gcr1_examples,
) *http.ServeMux {

	s.register_gcre2_todo(mux, handler.Todo)
	return mux
}

func (s *Server) register_gcre2_todo(
	mux *http.ServeMux,
	handler Handler_gcre2_todo,
) *http.ServeMux {

	s.register_gcret3_auth(mux, handler.Auth)
	s.register_gcret4_system(mux, handler.System)
	return mux
}

func (s *Server) register_gcret3_auth(
	mux *http.ServeMux,
	handler Handler_gcret3_auth,
) *http.ServeMux {

	mux.HandleFunc("/todo/auth/auth/Authenticate", func(resp http.ResponseWriter, req *http.Request) {
		var err error
		resp.Header().Set("Content-Type", "application/json")

		var arg0 *gcret3_auth.AuthRequest
		args := [1]interface{}{
			&arg0,
		}

		if req.Body != nil {
			if err := json.NewDecoder(req.Body).Decode(&args); err != nil {
				resp.WriteHeader(400)
				renderError(resp, err)
				return
			}
		}

		var out0 *gcret3_auth.AuthResponse
		out0, err = handler.Handler.Authenticate(arg0)
		result := &Result{
			Error: err,
			Returns: []interface{}{
				out0,
			},
		}

		bytes, err := json.Marshal(result)
		if err != nil {
			resp.WriteHeader(500)
			renderError(resp, err)
		}

		resp.WriteHeader(200)
		_, _ = resp.Write(bytes)
	})

	mux.HandleFunc("/todo/auth/auth/Current", func(resp http.ResponseWriter, req *http.Request) {
		var err error
		resp.Header().Set("Content-Type", "application/json")

		var out0 *gcre2_todo.User
		out0, err = handler.Handler.Current()
		result := &Result{
			Error: err,
			Returns: []interface{}{
				out0,
			},
		}

		bytes, err := json.Marshal(result)
		if err != nil {
			resp.WriteHeader(500)
			renderError(resp, err)
		}

		resp.WriteHeader(200)
		_, _ = resp.Write(bytes)
	})

	return mux
}

func (s *Server) register_gcret4_system(
	mux *http.ServeMux,
	handler Handler_gcret4_system,
) *http.ServeMux {

	mux.HandleFunc("/todo/system/system/Status", func(resp http.ResponseWriter, req *http.Request) {
		var err error
		resp.Header().Set("Content-Type", "application/json")

		var out0 *gcr1_examples.Failure
		out0, err = handler.Handler.Status()
		result := &Result{
			Error: err,
			Returns: []interface{}{
				out0,
			},
		}

		bytes, err := json.Marshal(result)
		if err != nil {
			resp.WriteHeader(500)
			renderError(resp, err)
		}

		resp.WriteHeader(200)
		_, _ = resp.Write(bytes)
	})

	return mux
}

func renderError(resp http.ResponseWriter, e error) {
	result := &Result{
		Error:   e,
		Returns: nil,
	}

	bytes, err := json.Marshal(result)
	if err != nil {
		_, _ = resp.Write([]byte(`{"error":"json processing error"}`))
	} else {
		_, _ = resp.Write(bytes)
	}
}
