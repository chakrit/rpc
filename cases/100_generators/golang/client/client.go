// <auto-generated />
//
// expected import: github.com/chakrit/rpc/examples/client
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"net/http"
	"time"

	rpc_root "github.com/chakrit/rpc/examples"
	rpc_todo "github.com/chakrit/rpc/examples/todo"
	rpc_todo_auth "github.com/chakrit/rpc/examples/todo/auth"

	rpc_todo_system "github.com/chakrit/rpc/examples/todo/system"
)

var (
	_ context.Context = nil
	_ time.Time       = time.Time{}
)

// github.com/chakrit/rpc/examples
var _ rpc_root.Interface = Client_rpc_root{}

type Client_rpc_root struct {
	*Client
	Todo Client_rpc_todo
}

func (c *Client_rpc_root) initialize(client *Client) {
	c.Client = client
	c.Todo = Client_rpc_todo{}
	c.Todo.initialize(client)
}

// github.com/chakrit/rpc/examples/todo
var _ rpc_todo.Interface = Client_rpc_todo{}

type Client_rpc_todo struct {
	*Client
	Auth   Client_rpc_todo_auth
	System Client_rpc_todo_system
}

func (c *Client_rpc_todo) initialize(client *Client) {
	c.Client = client
	c.Auth = Client_rpc_todo_auth{}
	c.Auth.initialize(client)
	c.System = Client_rpc_todo_system{}
	c.System.initialize(client)
}

// github.com/chakrit/rpc/examples/todo/auth
var _ rpc_todo_auth.Interface = Client_rpc_todo_auth{}

type Client_rpc_todo_auth struct {
	*Client
}

func (c *Client_rpc_todo_auth) initialize(client *Client) {
	c.Client = client
}

func (c Client_rpc_todo_auth) Authenticate(
	ctx context.Context,
	arg0 *rpc_todo_auth.AuthRequest,
) (
	out0 *rpc_todo_auth.AuthResponse,
	err error,
) {
	payload := []interface{}{arg0}

	buf := &bytes.Buffer{}
	if err = json.NewEncoder(buf).Encode(payload); err != nil {
		return
	}

	var req *http.Request
	req, err = http.NewRequest("POST", "http://"+c.Client.Options.Addr+"/examples/todo/auth/Authenticate", buf)
	if err != nil {
		return
	}

	req = req.WithContext(ctx)

	var resp *http.Response
	resp, err = c.HTTPClient.Do(req)
	if err != nil {
		return
	}

	returns := [1]interface{}{&out0}
	result := &Result{}
	result.Returns = returns[:]

	if resp.Body != nil {
		defer resp.Body.Close()

		if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
			return
		}
	}

	if result.Error != nil {
		err = result.Error
	}
	return
}

func (c Client_rpc_todo_auth) Current(
	ctx context.Context,
) (
	out0 *rpc_todo.User,
	err error,
) {
	payload := []interface{}{}

	buf := &bytes.Buffer{}
	if err = json.NewEncoder(buf).Encode(payload); err != nil {
		return
	}

	var req *http.Request
	req, err = http.NewRequest("POST", "http://"+c.Client.Options.Addr+"/examples/todo/auth/Current", buf)
	if err != nil {
		return
	}

	req = req.WithContext(ctx)

	var resp *http.Response
	resp, err = c.HTTPClient.Do(req)
	if err != nil {
		return
	}

	returns := [1]interface{}{&out0}
	result := &Result{}
	result.Returns = returns[:]

	if resp.Body != nil {
		defer resp.Body.Close()

		if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
			return
		}
	}

	if result.Error != nil {
		err = result.Error
	}
	return
}

// github.com/chakrit/rpc/examples/todo/system
var _ rpc_todo_system.Interface = Client_rpc_todo_system{}

type Client_rpc_todo_system struct {
	*Client
}

func (c *Client_rpc_todo_system) initialize(client *Client) {
	c.Client = client
}

func (c Client_rpc_todo_system) Status(
	ctx context.Context,
) (
	out0 *rpc_root.Failure,
	err error,
) {
	payload := []interface{}{}

	buf := &bytes.Buffer{}
	if err = json.NewEncoder(buf).Encode(payload); err != nil {
		return
	}

	var req *http.Request
	req, err = http.NewRequest("POST", "http://"+c.Client.Options.Addr+"/examples/todo/system/Status", buf)
	if err != nil {
		return
	}

	req = req.WithContext(ctx)

	var resp *http.Response
	resp, err = c.HTTPClient.Do(req)
	if err != nil {
		return
	}

	returns := [1]interface{}{&out0}
	result := &Result{}
	result.Returns = returns[:]

	if resp.Body != nil {
		defer resp.Body.Close()

		if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
			return
		}
	}

	if result.Error != nil {
		err = result.Error
	}
	return
}

type Result struct {
	Error   error         `json:"error"`
	Returns []interface{} `json:"returns"`
}

type Client struct {
	Options
	Client_rpc_root

	HTTPClient *http.Client
}

type Options struct {
	Addr string
}

func New(opts *Options) *Client {
	client := &Client{
		Options:         *opts,
		Client_rpc_root: Client_rpc_root{},
		HTTPClient:      &http.Client{},
	}
	client.Client_rpc_root.initialize(client)
	return client
}
