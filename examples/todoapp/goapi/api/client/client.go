// <auto-generated />
//
// expected import: github.com/chakrit/rpc/todo/api/client
package client

import (
	"bytes"
	"encoding/json"
	"net/http"
	"time"

	gcrt1_api "github.com/chakrit/rpc/todo/api"
)

var _ time.Time = time.Time{}

// github.com/chakrit/rpc/todo/api
var _ gcrt1_api.Interface = Client_gcrt1_api{}

type Client_gcrt1_api struct {
	*Client
}

func (c *Client_gcrt1_api) initialize(client *Client) {
	c.Client = client
}

func (c Client_gcrt1_api) Create(
	arg0 string,
) (
	out0 *gcrt1_api.TodoItem,
	err error,
) {
	payload := []interface{}{arg0}

	buf := &bytes.Buffer{}
	if err = json.NewEncoder(buf).Encode(payload); err != nil {
		return
	}

	var req *http.Request
	req, err = http.NewRequest("POST", "http://"+c.Client.Options.Addr+"/api/Create", buf)
	if err != nil {
		return
	}

	var resp *http.Response
	resp, err = c.HTTPClient.Do(req)
	if err != nil {
		return
	}

	returns := [1]interface{}{&out0}
	result := &Result{}
	result.Returns = returns[:]

	if resp.Body != nil {
		defer resp.Body.Close()

		if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
			return
		}
	}

	if result.Error != nil {
		err = result.Error
	}
	return
}

func (c Client_gcrt1_api) Destroy(
	arg0 int64,
) (
	out0 *gcrt1_api.TodoItem,
	err error,
) {
	payload := []interface{}{arg0}

	buf := &bytes.Buffer{}
	if err = json.NewEncoder(buf).Encode(payload); err != nil {
		return
	}

	var req *http.Request
	req, err = http.NewRequest("POST", "http://"+c.Client.Options.Addr+"/api/Destroy", buf)
	if err != nil {
		return
	}

	var resp *http.Response
	resp, err = c.HTTPClient.Do(req)
	if err != nil {
		return
	}

	returns := [1]interface{}{&out0}
	result := &Result{}
	result.Returns = returns[:]

	if resp.Body != nil {
		defer resp.Body.Close()

		if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
			return
		}
	}

	if result.Error != nil {
		err = result.Error
	}
	return
}

func (c Client_gcrt1_api) List() (
	out0 []*gcrt1_api.TodoItem,
	err error,
) {
	payload := []interface{}{}

	buf := &bytes.Buffer{}
	if err = json.NewEncoder(buf).Encode(payload); err != nil {
		return
	}

	var req *http.Request
	req, err = http.NewRequest("POST", "http://"+c.Client.Options.Addr+"/api/List", buf)
	if err != nil {
		return
	}

	var resp *http.Response
	resp, err = c.HTTPClient.Do(req)
	if err != nil {
		return
	}

	returns := [1]interface{}{&out0}
	result := &Result{}
	result.Returns = returns[:]

	if resp.Body != nil {
		defer resp.Body.Close()

		if err = json.NewDecoder(resp.Body).Decode(result); err != nil {
			return
		}
	}

	if result.Error != nil {
		err = result.Error
	}
	return
}

type Result struct {
	Error   error         `json:"error"`
	Returns []interface{} `json:"returns"`
}

type Client struct {
	Options
	Client_gcrt1_api

	HTTPClient *http.Client
}

type Options struct {
	Addr string
}

func New(opts *Options) *Client {
	client := &Client{
		Options:          *opts,
		Client_gcrt1_api: Client_gcrt1_api{},
		HTTPClient:       &http.Client{},
	}
	client.Client_gcrt1_api.initialize(client)
	return client
}
