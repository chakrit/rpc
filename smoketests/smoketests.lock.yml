- name: ./smoketests.yml \ Build \ Generate
  commands:
    - command: go generate ../...
      checks:
        - name: exitcode
          data:
            - "0"
- name: ./smoketests.yml \ Build \ Tests
  commands:
    - command: go test -v ../...
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - "?   \tgithub.com/chakrit/rpc\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/generator\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/generator/elm\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/generator/golang\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/generator/tmpldata\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/internal\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/lexer\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/parser\t[no test files]"
            - "?   \tgithub.com/chakrit/rpc/spec\t[no test files]"
- name: ./smoketests.yml \ Build \ Compile
  commands:
    - command: go install ..
      checks:
        - name: exitcode
          data:
            - "0"
- name: ./smoketests.yml \ Basics \ Lex
  commands:
    - command: $(go env GOPATH)/bin/rpc -lex "*.rpc"
      checks:
        - name: exitcode
          data:
            - "1"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - '[error] *.rpc: open *.rpc: no such file or directory'
- name: ./smoketests.yml \ Basics \ Parse
  commands:
    - command: $(go env GOPATH)/bin/rpc -parse "*.rpc"
      checks:
        - name: exitcode
          data:
            - "1"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - '[error] *.rpc: open *.rpc: no such file or directory'
- name: ./smoketests.yml \ Generators
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
- name: ./smoketests.yml \ Generators \ Elm
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*/*.elm
          data: []
- name: ./smoketests.yml \ Generators \ Elm \ Simple
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*/*.elm
          data: []
    - command: $(go env GOPATH)/bin/rpc -gen elm -out /tmp/rpc/elm todo-simple.rpc
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data:
            - '-----BEGIN Rpc.elm-----'
            - module Rpc exposing (..)
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Http
            - import Json.Decode as D
            - import Json.Encode as E
            - import Dict exposing (Dict)
            - import Task exposing (Task)
            - import Time exposing (Posix)
            - import Bytes exposing (Bytes)
            - import Bytes.Encode
            - import RpcUtil exposing (Config, RpcError, RpcResult, decodeApply, fromHttpResult)
            - ""
            - ""
            - ""
            - type alias Failure =
            - '    { code : String'
            - '    , description : String'
            - '    }'
            - ""
            - 'defaultFailure : Failure'
            - defaultFailure =
            - '    { code = ""'
            - '    , description = ""'
            - '    }'
            - ""
            - 'encodeFailure : Failure -> E.Value'
            - encodeFailure obj =
            - '    E.object'
            - '        [ ( "code", E.string obj.code )'
            - '        , ( "description", E.string obj.description )'
            - '        ]'
            - ""
            - 'decodeFailure : D.Decoder Failure'
            - decodeFailure =
            - '    D.map2 Failure'
            - '                (D.string'
            - '                    |> D.field "code"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "description"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '    '
            - ""
            - type alias TodoItem =
            - '    { completed : Bool'
            - '    , ctime : Posix'
            - '    , description : String'
            - '    , metadata : String'
            - '    , uuid : String'
            - '    }'
            - ""
            - 'defaultTodoItem : TodoItem'
            - defaultTodoItem =
            - '    { completed = False'
            - '    , ctime = Time.millisToPosix 0'
            - '    , description = ""'
            - '    , metadata = ""'
            - '    , uuid = ""'
            - '    }'
            - ""
            - 'encodeTodoItem : TodoItem -> E.Value'
            - encodeTodoItem obj =
            - '    E.object'
            - '        [ ( "completed", E.bool obj.completed )'
            - '        , ( "ctime", (Time.posixToMillis >> toFloat >> (\f -> f/1000.0)
              >> E.float) obj.ctime )'
            - '        , ( "description", E.string obj.description )'
            - '        , ( "metadata", E.string obj.metadata )'
            - '        , ( "uuid", E.string obj.uuid )'
            - '        ]'
            - ""
            - 'decodeTodoItem : D.Decoder TodoItem'
            - decodeTodoItem =
            - '    D.map5 TodoItem'
            - '                (D.bool'
            - '                    |> D.field "completed"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (False))'
            - '                )'
            - '                ((D.map ((\f -> f * 1000.0) >> round >> Time.millisToPosix)
              D.float)'
            - '                    |> D.field "ctime"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (Time.millisToPosix
              0))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "description"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "metadata"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "uuid"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '    '
            - ""
            - ""
            - ""
            - ""
            - ""
            - type alias InputForDelete =
            - '    (String)'
            - ""
            - 'encodeInputForDelete : InputForDelete -> E.Value'
            - encodeInputForDelete
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.string arg0'
            - '            ]'
            - ""
            - 'decodeInputForDelete : D.Decoder InputForDelete'
            - decodeInputForDelete =
            - '        D.string'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (""))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForDelete =
            - '    (TodoItem)'
            - ""
            - 'encodeOutputForDelete : OutputForDelete -> E.Value'
            - encodeOutputForDelete
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeTodoItem arg0'
            - '            ]'
            - ""
            - 'decodeOutputForDelete : D.Decoder OutputForDelete'
            - decodeOutputForDelete =
            - '        decodeTodoItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultTodoItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForGet =
            - '    (String)'
            - ""
            - 'encodeInputForGet : InputForGet -> E.Value'
            - encodeInputForGet
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.string arg0'
            - '            ]'
            - ""
            - 'decodeInputForGet : D.Decoder InputForGet'
            - decodeInputForGet =
            - '        D.string'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (""))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForGet =
            - '    (TodoItem)'
            - ""
            - 'encodeOutputForGet : OutputForGet -> E.Value'
            - encodeOutputForGet
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeTodoItem arg0'
            - '            ]'
            - ""
            - 'decodeOutputForGet : D.Decoder OutputForGet'
            - decodeOutputForGet =
            - '        decodeTodoItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultTodoItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForList =
            - '    (())'
            - ""
            - 'encodeInputForList : InputForList -> E.Value'
            - encodeInputForList
            - '    () ='
            - '        E.list (identity)'
            - '            ['
            - '            ]'
            - ""
            - 'decodeInputForList : D.Decoder InputForList'
            - decodeInputForList =
            - '        D.succeed ()'
            - ""
            - type alias OutputForList =
            - '    (List (TodoItem))'
            - ""
            - 'encodeOutputForList : OutputForList -> E.Value'
            - encodeOutputForList
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.list (encodeTodoItem) arg0'
            - '            ]'
            - ""
            - 'decodeOutputForList : D.Decoder OutputForList'
            - decodeOutputForList =
            - '        D.list (decodeTodoItem)'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault ([]))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForPut =
            - '    (TodoItem)'
            - ""
            - 'encodeInputForPut : InputForPut -> E.Value'
            - encodeInputForPut
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeTodoItem arg0'
            - '            ]'
            - ""
            - 'decodeInputForPut : D.Decoder InputForPut'
            - decodeInputForPut =
            - '        decodeTodoItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultTodoItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForPut =
            - '    (TodoItem)'
            - ""
            - 'encodeOutputForPut : OutputForPut -> E.Value'
            - encodeOutputForPut
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeTodoItem arg0'
            - '            ]'
            - ""
            - 'decodeOutputForPut : D.Decoder OutputForPut'
            - decodeOutputForPut =
            - '        decodeTodoItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultTodoItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - ""
            - ""
            - 'callDeleteTask : Config -> InputForDelete -> Task RpcError OutputForDelete'
            - callDeleteTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForDelete input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForDelete'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/Delete"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callDelete : Config -> InputForDelete -> (RpcResult OutputForDelete
              -> a) -> Cmd a'
            - callDelete config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForDelete input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForDelete)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/Delete"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callGetTask : Config -> InputForGet -> Task RpcError OutputForGet'
            - callGetTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForGet input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForGet'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/Get"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callGet : Config -> InputForGet -> (RpcResult OutputForGet -> a) ->
              Cmd a'
            - callGet config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForGet input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForGet)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/Get"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callListTask : Config -> InputForList -> Task RpcError OutputForList'
            - callListTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForList input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForList'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/List"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callList : Config -> InputForList -> (RpcResult OutputForList -> a)
              -> Cmd a'
            - callList config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForList input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForList)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/List"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callPutTask : Config -> InputForPut -> Task RpcError OutputForPut'
            - callPutTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForPut input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForPut'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/Put"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callPut : Config -> InputForPut -> (RpcResult OutputForPut -> a) ->
              Cmd a'
            - callPut config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForPut input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForPut)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/Put"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - '-----END Rpc.elm-----'
            - ""
            - '-----BEGIN RpcUtil.elm-----'
            - module RpcUtil exposing
            - '    ( Config'
            - '    , RpcError(..)'
            - '    , RpcResult'
            - '    , configDecoder'
            - '    , decodeApply'
            - '    , decodeString'
            - '    , decodeValue'
            - '    , decoder'
            - '    , errorToString'
            - '    , fromHttpResult'
            - '    , map'
            - '    , resolver'
            - '    )'
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Array exposing (Array)
            - import Bitwise as Bits
            - import Bytes exposing (Bytes)
            - import Bytes.Decode as BytesDec
            - import Bytes.Encode as BytesEnc
            - import Dict exposing (Dict)
            - import Http exposing (Error(..), Resolver, Response(..))
            - import Json.Decode as JsonDec
            - ""
            - ""
            - type alias Config =
            - '    { baseUrl : String'
            - '    , headers : List Http.Header'
            - '    }'
            - ""
            - ""
            - 'configDecoder : JsonDec.Decoder Config'
            - configDecoder =
            - '    let'
            - '        mapHeader : Array String -> Http.Header'
            - '        mapHeader arr ='
            - '            let'
            - '                header ='
            - '                    Array.get 0 arr |> Maybe.withDefault ""'
            - ""
            - '                content ='
            - '                    Array.get 1 arr |> Maybe.withDefault ""'
            - '            in'
            - '            Http.header header content'
            - ""
            - '        mapHeaderArray : Array (Array String) -> List Http.Header'
            - '        mapHeaderArray arr ='
            - '            arr |> Array.map mapHeader |> Array.toList'
            - '    in'
            - '    JsonDec.map2 Config'
            - '        (JsonDec.field "baseUrl" <| JsonDec.string)'
            - '        (JsonDec.field "headers" <| JsonDec.map mapHeaderArray (JsonDec.array
              (JsonDec.array JsonDec.string)))'
            - ""
            - ""
            - 'decodeApply : JsonDec.Decoder a -> JsonDec.Decoder (a -> b) -> JsonDec.Decoder
              b'
            - decodeApply fieldDec partial =
            - '    JsonDec.andThen (\p -> JsonDec.map p fieldDec) partial'
            - ""
            - ""
            - type RpcError
            - '    = HttpError Http.Error'
            - '    | JsonError JsonDec.Error'
            - '    | ApiError String'
            - ""
            - ""
            - type alias RpcResult a =
            - '    Result RpcError a'
            - ""
            - ""
            - 'fromHttpResult : Result Http.Error (RpcResult a) -> RpcResult a'
            - fromHttpResult httpResult =
            - '    case httpResult of'
            - '        Err err ->'
            - '            Err (HttpError err)'
            - ""
            - '        Ok result ->'
            - '            -- unwrap inner result'
            - '            result'
            - ""
            - ""
            - 'errorToString : RpcError -> String'
            - errorToString httpErr =
            - '    case httpErr of'
            - '        HttpError (BadUrl str) ->'
            - '            "Bad URL: " ++ str'
            - ""
            - '        HttpError Timeout ->'
            - '            "Network Timeout"'
            - ""
            - '        HttpError NetworkError ->'
            - '            "Network Error"'
            - ""
            - '        HttpError (BadStatus code) ->'
            - '            "Bad Status Code: " ++ String.fromInt code'
            - ""
            - '        HttpError (BadBody str) ->'
            - '            "Malformed Response: " ++ str'
            - ""
            - '        JsonError err ->'
            - '            "JSON Error: " ++ JsonDec.errorToString err'
            - ""
            - '        ApiError str ->'
            - '            str'
            - ""
            - ""
            - 'resolver : JsonDec.Decoder a -> Resolver RpcError a'
            - resolver decoder_ =
            - '    Http.stringResolver'
            - '        (\resp ->'
            - '            case resp of'
            - '                BadUrl_ s ->'
            - '                    Err (HttpError (BadUrl s))'
            - ""
            - '                Timeout_ ->'
            - '                    Err (HttpError Timeout)'
            - ""
            - '                NetworkError_ ->'
            - '                    Err (HttpError NetworkError)'
            - ""
            - '                BadStatus_ metadata _ ->'
            - '                    Err (HttpError (BadStatus metadata.statusCode))'
            - ""
            - '                GoodStatus_ metadata str ->'
            - '                    decodeString (decoder decoder_) str'
            - '        )'
            - ""
            - ""
            - 'map : (RpcError -> msg) -> (a -> msg) -> RpcResult a -> msg'
            - map errMap okMap result =
            - '    case result of'
            - '        Err err ->'
            - '            errMap err'
            - ""
            - '        Ok obj ->'
            - '            okMap obj'
            - ""
            - ""
            - 'decodeString : JsonDec.Decoder (RpcResult a) -> String -> RpcResult
              a'
            - decodeString decoder_ str =
            - '    case JsonDec.decodeString decoder_ str of'
            - '        Ok v ->'
            - '            -- unwrap inner Result'
            - '            v'
            - ""
            - '        Err err ->'
            - '            Err (JsonError err)'
            - ""
            - ""
            - 'decodeValue : JsonDec.Decoder (RpcResult a) -> JsonDec.Value -> RpcResult
              a'
            - decodeValue decoder_ value =
            - '    case JsonDec.decodeValue decoder_ value of'
            - '        Ok v ->'
            - '            -- unwrap inner Result'
            - '            v'
            - ""
            - '        Err err ->'
            - '            Err (JsonError err)'
            - ""
            - ""
            - 'decoder : JsonDec.Decoder a -> JsonDec.Decoder (RpcResult a)'
            - decoder returnDecoder =
            - '    let'
            - '        mapToResult : Maybe String -> a -> RpcResult a'
            - '        mapToResult err ret ='
            - '            case err of'
            - '                Just str ->'
            - '                    Err (ApiError str)'
            - ""
            - '                Nothing ->'
            - '                    Ok ret'
            - '    in'
            - '    JsonDec.map2 mapToResult'
            - '        (JsonDec.field "error" (JsonDec.maybe JsonDec.string))'
            - '        (JsonDec.field "returns" returnDecoder)'
            - '-----END RpcUtil.elm-----'
            - ""
        - name: /tmp/rpc/elm/*/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*/*.elm
          data: []
- name: ./smoketests.yml \ Generators \ Elm \ Complex
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*/*.elm
          data: []
    - command: $(go env GOPATH)/bin/rpc -gen elm -out /tmp/rpc/elm todo-complex.rpc
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data:
            - '-----BEGIN Rpc.elm-----'
            - module Rpc exposing (..)
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Http
            - import Json.Decode as D
            - import Json.Encode as E
            - import Dict exposing (Dict)
            - import Task exposing (Task)
            - import Time exposing (Posix)
            - import Bytes exposing (Bytes)
            - import Bytes.Encode
            - import RpcUtil exposing (Config, RpcError, RpcResult, decodeApply, fromHttpResult)
            - ""
            - ""
            - ""
            - type alias Failure =
            - '    { code : String'
            - '    , description : String'
            - '    }'
            - ""
            - 'defaultFailure : Failure'
            - defaultFailure =
            - '    { code = ""'
            - '    , description = ""'
            - '    }'
            - ""
            - 'encodeFailure : Failure -> E.Value'
            - encodeFailure obj =
            - '    E.object'
            - '        [ ( "code", E.string obj.code )'
            - '        , ( "description", E.string obj.description )'
            - '        ]'
            - ""
            - 'decodeFailure : D.Decoder Failure'
            - decodeFailure =
            - '    D.map2 Failure'
            - '                (D.string'
            - '                    |> D.field "code"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "description"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '    '
            - '-----END Rpc.elm-----'
            - ""
            - '-----BEGIN RpcUtil.elm-----'
            - module RpcUtil exposing
            - '    ( Config'
            - '    , RpcError(..)'
            - '    , RpcResult'
            - '    , configDecoder'
            - '    , decodeApply'
            - '    , decodeString'
            - '    , decodeValue'
            - '    , decoder'
            - '    , errorToString'
            - '    , fromHttpResult'
            - '    , map'
            - '    , resolver'
            - '    )'
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Array exposing (Array)
            - import Bitwise as Bits
            - import Bytes exposing (Bytes)
            - import Bytes.Decode as BytesDec
            - import Bytes.Encode as BytesEnc
            - import Dict exposing (Dict)
            - import Http exposing (Error(..), Resolver, Response(..))
            - import Json.Decode as JsonDec
            - ""
            - ""
            - type alias Config =
            - '    { baseUrl : String'
            - '    , headers : List Http.Header'
            - '    }'
            - ""
            - ""
            - 'configDecoder : JsonDec.Decoder Config'
            - configDecoder =
            - '    let'
            - '        mapHeader : Array String -> Http.Header'
            - '        mapHeader arr ='
            - '            let'
            - '                header ='
            - '                    Array.get 0 arr |> Maybe.withDefault ""'
            - ""
            - '                content ='
            - '                    Array.get 1 arr |> Maybe.withDefault ""'
            - '            in'
            - '            Http.header header content'
            - ""
            - '        mapHeaderArray : Array (Array String) -> List Http.Header'
            - '        mapHeaderArray arr ='
            - '            arr |> Array.map mapHeader |> Array.toList'
            - '    in'
            - '    JsonDec.map2 Config'
            - '        (JsonDec.field "baseUrl" <| JsonDec.string)'
            - '        (JsonDec.field "headers" <| JsonDec.map mapHeaderArray (JsonDec.array
              (JsonDec.array JsonDec.string)))'
            - ""
            - ""
            - 'decodeApply : JsonDec.Decoder a -> JsonDec.Decoder (a -> b) -> JsonDec.Decoder
              b'
            - decodeApply fieldDec partial =
            - '    JsonDec.andThen (\p -> JsonDec.map p fieldDec) partial'
            - ""
            - ""
            - type RpcError
            - '    = HttpError Http.Error'
            - '    | JsonError JsonDec.Error'
            - '    | ApiError String'
            - ""
            - ""
            - type alias RpcResult a =
            - '    Result RpcError a'
            - ""
            - ""
            - 'fromHttpResult : Result Http.Error (RpcResult a) -> RpcResult a'
            - fromHttpResult httpResult =
            - '    case httpResult of'
            - '        Err err ->'
            - '            Err (HttpError err)'
            - ""
            - '        Ok result ->'
            - '            -- unwrap inner result'
            - '            result'
            - ""
            - ""
            - 'errorToString : RpcError -> String'
            - errorToString httpErr =
            - '    case httpErr of'
            - '        HttpError (BadUrl str) ->'
            - '            "Bad URL: " ++ str'
            - ""
            - '        HttpError Timeout ->'
            - '            "Network Timeout"'
            - ""
            - '        HttpError NetworkError ->'
            - '            "Network Error"'
            - ""
            - '        HttpError (BadStatus code) ->'
            - '            "Bad Status Code: " ++ String.fromInt code'
            - ""
            - '        HttpError (BadBody str) ->'
            - '            "Malformed Response: " ++ str'
            - ""
            - '        JsonError err ->'
            - '            "JSON Error: " ++ JsonDec.errorToString err'
            - ""
            - '        ApiError str ->'
            - '            str'
            - ""
            - ""
            - 'resolver : JsonDec.Decoder a -> Resolver RpcError a'
            - resolver decoder_ =
            - '    Http.stringResolver'
            - '        (\resp ->'
            - '            case resp of'
            - '                BadUrl_ s ->'
            - '                    Err (HttpError (BadUrl s))'
            - ""
            - '                Timeout_ ->'
            - '                    Err (HttpError Timeout)'
            - ""
            - '                NetworkError_ ->'
            - '                    Err (HttpError NetworkError)'
            - ""
            - '                BadStatus_ metadata _ ->'
            - '                    Err (HttpError (BadStatus metadata.statusCode))'
            - ""
            - '                GoodStatus_ metadata str ->'
            - '                    decodeString (decoder decoder_) str'
            - '        )'
            - ""
            - ""
            - 'map : (RpcError -> msg) -> (a -> msg) -> RpcResult a -> msg'
            - map errMap okMap result =
            - '    case result of'
            - '        Err err ->'
            - '            errMap err'
            - ""
            - '        Ok obj ->'
            - '            okMap obj'
            - ""
            - ""
            - 'decodeString : JsonDec.Decoder (RpcResult a) -> String -> RpcResult
              a'
            - decodeString decoder_ str =
            - '    case JsonDec.decodeString decoder_ str of'
            - '        Ok v ->'
            - '            -- unwrap inner Result'
            - '            v'
            - ""
            - '        Err err ->'
            - '            Err (JsonError err)'
            - ""
            - ""
            - 'decodeValue : JsonDec.Decoder (RpcResult a) -> JsonDec.Value -> RpcResult
              a'
            - decodeValue decoder_ value =
            - '    case JsonDec.decodeValue decoder_ value of'
            - '        Ok v ->'
            - '            -- unwrap inner Result'
            - '            v'
            - ""
            - '        Err err ->'
            - '            Err (JsonError err)'
            - ""
            - ""
            - 'decoder : JsonDec.Decoder a -> JsonDec.Decoder (RpcResult a)'
            - decoder returnDecoder =
            - '    let'
            - '        mapToResult : Maybe String -> a -> RpcResult a'
            - '        mapToResult err ret ='
            - '            case err of'
            - '                Just str ->'
            - '                    Err (ApiError str)'
            - ""
            - '                Nothing ->'
            - '                    Ok ret'
            - '    in'
            - '    JsonDec.map2 mapToResult'
            - '        (JsonDec.field "error" (JsonDec.maybe JsonDec.string))'
            - '        (JsonDec.field "returns" returnDecoder)'
            - '-----END RpcUtil.elm-----'
            - ""
        - name: /tmp/rpc/elm/*/*.elm
          data:
            - '-----BEGIN System.elm-----'
            - module Rpc.System exposing (..)
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Http
            - import Json.Decode as D
            - import Json.Encode as E
            - import Dict exposing (Dict)
            - import Task exposing (Task)
            - import Time exposing (Posix)
            - import Bytes exposing (Bytes)
            - import Bytes.Encode
            - import RpcUtil exposing (Config, RpcError, RpcResult, decodeApply, fromHttpResult)
            - import Rpc
            - ""
            - ""
            - ""
            - ""
            - ""
            - ""
            - ""
            - type alias InputForStatus =
            - '    (())'
            - ""
            - 'encodeInputForStatus : InputForStatus -> E.Value'
            - encodeInputForStatus
            - '    () ='
            - '        E.list (identity)'
            - '            ['
            - '            ]'
            - ""
            - 'decodeInputForStatus : D.Decoder InputForStatus'
            - decodeInputForStatus =
            - '        D.succeed ()'
            - ""
            - type alias OutputForStatus =
            - '    (Rpc.Failure)'
            - ""
            - 'encodeOutputForStatus : OutputForStatus -> E.Value'
            - encodeOutputForStatus
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ Rpc.encodeFailure arg0'
            - '            ]'
            - ""
            - 'decodeOutputForStatus : D.Decoder OutputForStatus'
            - decodeOutputForStatus =
            - '        Rpc.decodeFailure'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (Rpc.defaultFailure))'
            - '            |> D.map (\a -> (a))'
            - ""
            - ""
            - ""
            - 'callStatusTask : Config -> InputForStatus -> Task RpcError OutputForStatus'
            - callStatusTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForStatus input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForStatus'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/system/Status"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callStatus : Config -> InputForStatus -> (RpcResult OutputForStatus
              -> a) -> Cmd a'
            - callStatus config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForStatus input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForStatus)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/system/Status"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - '-----END System.elm-----'
            - ""
            - '-----BEGIN Todos.elm-----'
            - module Rpc.Todos exposing (..)
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Http
            - import Json.Decode as D
            - import Json.Encode as E
            - import Dict exposing (Dict)
            - import Task exposing (Task)
            - import Time exposing (Posix)
            - import Bytes exposing (Bytes)
            - import Bytes.Encode
            - import RpcUtil exposing (Config, RpcError, RpcResult, decodeApply, fromHttpResult)
            - ""
            - ""
            - ""
            - type alias Item =
            - '    { assignee : String'
            - '    , author : String'
            - '    , category : String'
            - '    , ctime : Posix'
            - '    , description : String'
            - '    , dueDate : Posix'
            - '    , id : String'
            - '    , state : State'
            - '    , tags : List (String)'
            - '    }'
            - ""
            - 'defaultItem : Item'
            - defaultItem =
            - '    { assignee = ""'
            - '    , author = ""'
            - '    , category = ""'
            - '    , ctime = Time.millisToPosix 0'
            - '    , description = ""'
            - '    , dueDate = Time.millisToPosix 0'
            - '    , id = ""'
            - '    , state = defaultState'
            - '    , tags = []'
            - '    }'
            - ""
            - 'encodeItem : Item -> E.Value'
            - encodeItem obj =
            - '    E.object'
            - '        [ ( "assignee", E.string obj.assignee )'
            - '        , ( "author", E.string obj.author )'
            - '        , ( "category", E.string obj.category )'
            - '        , ( "ctime", (Time.posixToMillis >> toFloat >> (\f -> f/1000.0)
              >> E.float) obj.ctime )'
            - '        , ( "description", E.string obj.description )'
            - '        , ( "dueDate", (Time.posixToMillis >> toFloat >> (\f -> f/1000.0)
              >> E.float) obj.dueDate )'
            - '        , ( "id", E.string obj.id )'
            - '        , ( "state", encodeState obj.state )'
            - '        , ( "tags", E.list (E.string) obj.tags )'
            - '        ]'
            - ""
            - 'decodeItem : D.Decoder Item'
            - decodeItem =
            - '    D.succeed Item'
            - '            |> (D.string'
            - '                |> D.field "assignee"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> (D.string'
            - '                |> D.field "author"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> (D.string'
            - '                |> D.field "category"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> ((D.map ((\f -> f * 1000.0) >> round >> Time.millisToPosix)
              D.float)'
            - '                |> D.field "ctime"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Time.millisToPosix 0))'
            - '                |> decodeApply)'
            - '            |> (D.string'
            - '                |> D.field "description"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> ((D.map ((\f -> f * 1000.0) >> round >> Time.millisToPosix)
              D.float)'
            - '                |> D.field "dueDate"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Time.millisToPosix 0))'
            - '                |> decodeApply)'
            - '            |> (D.string'
            - '                |> D.field "id"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> (decodeState'
            - '                |> D.field "state"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (defaultState))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.string)'
            - '                |> D.field "tags"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '    '
            - ""
            - ""
            - ""
            - type State
            - '    = New'
            - '    | InProgress'
            - '    | Overdue'
            - '    | Completed'
            - ""
            - 'allState : List State'
            - allState =
            - '    [ New'
            - '    , InProgress'
            - '    , Overdue'
            - '    , Completed'
            - '    ]'
            - ""
            - 'pairsOfState : List ( String, State )'
            - pairsOfState =
            - '    [ ( "new", New )'
            - '    , ( "in-progress", InProgress )'
            - '    , ( "overdue", Overdue )'
            - '    , ( "completed", Completed )'
            - '    ]'
            - ""
            - 'titlePairsOfState : List ( String, String )'
            - titlePairsOfState =
            - '    [ ( "new", "New" )'
            - '    , ( "in-progress", "In Progress" )'
            - '    , ( "overdue", "Overdue" )'
            - '    , ( "completed", "Completed" )'
            - '    ]'
            - ""
            - 'stringToState : String -> Maybe State'
            - stringToState str =
            - '    case str of'
            - '        "new" ->'
            - '            Just New'
            - '        "in-progress" ->'
            - '            Just InProgress'
            - '        "overdue" ->'
            - '            Just Overdue'
            - '        "completed" ->'
            - '            Just Completed'
            - '        _ ->'
            - '            Nothing'
            - ""
            - 'stringFromState : State -> String'
            - stringFromState v =
            - '    case v of'
            - '        New ->'
            - '            "new"'
            - '        InProgress ->'
            - '            "in-progress"'
            - '        Overdue ->'
            - '            "overdue"'
            - '        Completed ->'
            - '            "completed"'
            - ""
            - 'titleStringFromState : State -> String'
            - titleStringFromState v =
            - '    case v of'
            - '        New ->'
            - '            "New"'
            - '        InProgress ->'
            - '            "In Progress"'
            - '        Overdue ->'
            - '            "Overdue"'
            - '        Completed ->'
            - '            "Completed"'
            - ""
            - defaultState =
            - '    New'
            - ""
            - 'encodeState : State -> E.Value'
            - encodeState =
            - '    stringFromState >> E.string'
            - ""
            - 'decodeState : D.Decoder State'
            - decodeState =
            - '    D.string'
            - '        |> D.map stringToState'
            - '        |> D.map (Maybe.withDefault defaultState)'
            - ""
            - ""
            - ""
            - type alias InputForDelete =
            - '    (String)'
            - ""
            - 'encodeInputForDelete : InputForDelete -> E.Value'
            - encodeInputForDelete
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.string arg0'
            - '            ]'
            - ""
            - 'decodeInputForDelete : D.Decoder InputForDelete'
            - decodeInputForDelete =
            - '        D.string'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (""))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForDelete =
            - '    (Item)'
            - ""
            - 'encodeOutputForDelete : OutputForDelete -> E.Value'
            - encodeOutputForDelete
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeItem arg0'
            - '            ]'
            - ""
            - 'decodeOutputForDelete : D.Decoder OutputForDelete'
            - decodeOutputForDelete =
            - '        decodeItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForGet =
            - '    (String)'
            - ""
            - 'encodeInputForGet : InputForGet -> E.Value'
            - encodeInputForGet
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.string arg0'
            - '            ]'
            - ""
            - 'decodeInputForGet : D.Decoder InputForGet'
            - decodeInputForGet =
            - '        D.string'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (""))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForGet =
            - '    (Item)'
            - ""
            - 'encodeOutputForGet : OutputForGet -> E.Value'
            - encodeOutputForGet
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeItem arg0'
            - '            ]'
            - ""
            - 'decodeOutputForGet : D.Decoder OutputForGet'
            - decodeOutputForGet =
            - '        decodeItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForList =
            - '    (())'
            - ""
            - 'encodeInputForList : InputForList -> E.Value'
            - encodeInputForList
            - '    () ='
            - '        E.list (identity)'
            - '            ['
            - '            ]'
            - ""
            - 'decodeInputForList : D.Decoder InputForList'
            - decodeInputForList =
            - '        D.succeed ()'
            - ""
            - type alias OutputForList =
            - '    (List (Item))'
            - ""
            - 'encodeOutputForList : OutputForList -> E.Value'
            - encodeOutputForList
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.list (encodeItem) arg0'
            - '            ]'
            - ""
            - 'decodeOutputForList : D.Decoder OutputForList'
            - decodeOutputForList =
            - '        D.list (decodeItem)'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault ([]))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForPut =
            - '    (String)'
            - ""
            - 'encodeInputForPut : InputForPut -> E.Value'
            - encodeInputForPut
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ E.string arg0'
            - '            ]'
            - ""
            - 'decodeInputForPut : D.Decoder InputForPut'
            - decodeInputForPut =
            - '        D.string'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (""))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForPut =
            - '    (Item)'
            - ""
            - 'encodeOutputForPut : OutputForPut -> E.Value'
            - encodeOutputForPut
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeItem arg0'
            - '            ]'
            - ""
            - 'decodeOutputForPut : D.Decoder OutputForPut'
            - decodeOutputForPut =
            - '        decodeItem'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultItem))'
            - '            |> D.map (\a -> (a))'
            - ""
            - ""
            - ""
            - 'callDeleteTask : Config -> InputForDelete -> Task RpcError OutputForDelete'
            - callDeleteTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForDelete input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForDelete'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/Delete"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callDelete : Config -> InputForDelete -> (RpcResult OutputForDelete
              -> a) -> Cmd a'
            - callDelete config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForDelete input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForDelete)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/Delete"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callGetTask : Config -> InputForGet -> Task RpcError OutputForGet'
            - callGetTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForGet input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForGet'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/Get"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callGet : Config -> InputForGet -> (RpcResult OutputForGet -> a) ->
              Cmd a'
            - callGet config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForGet input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForGet)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/Get"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callListTask : Config -> InputForList -> Task RpcError OutputForList'
            - callListTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForList input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForList'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/List"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callList : Config -> InputForList -> (RpcResult OutputForList -> a)
              -> Cmd a'
            - callList config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForList input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForList)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/List"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callPutTask : Config -> InputForPut -> Task RpcError OutputForPut'
            - callPutTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForPut input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForPut'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/Put"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callPut : Config -> InputForPut -> (RpcResult OutputForPut -> a) ->
              Cmd a'
            - callPut config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForPut input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForPut)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/todos/Put"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - '-----END Todos.elm-----'
            - ""
        - name: /tmp/rpc/elm/*/*/*.elm
          data:
            - '-----BEGIN Auth.elm-----'
            - module Rpc.System.Auth exposing (..)
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Http
            - import Json.Decode as D
            - import Json.Encode as E
            - import Dict exposing (Dict)
            - import Task exposing (Task)
            - import Time exposing (Posix)
            - import Bytes exposing (Bytes)
            - import Bytes.Encode
            - import RpcUtil exposing (Config, RpcError, RpcResult, decodeApply, fromHttpResult)
            - import Rpc
            - ""
            - ""
            - ""
            - type alias AuthRequest =
            - '    { authData : String'
            - '    , provider : String'
            - '    , username : String'
            - '    }'
            - ""
            - 'defaultAuthRequest : AuthRequest'
            - defaultAuthRequest =
            - '    { authData = ""'
            - '    , provider = ""'
            - '    , username = ""'
            - '    }'
            - ""
            - 'encodeAuthRequest : AuthRequest -> E.Value'
            - encodeAuthRequest obj =
            - '    E.object'
            - '        [ ( "authData", E.string obj.authData )'
            - '        , ( "provider", E.string obj.provider )'
            - '        , ( "username", E.string obj.username )'
            - '        ]'
            - ""
            - 'decodeAuthRequest : D.Decoder AuthRequest'
            - decodeAuthRequest =
            - '    D.map3 AuthRequest'
            - '                (D.string'
            - '                    |> D.field "authData"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "provider"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "username"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '    '
            - ""
            - type alias AuthResponse =
            - '    { failure : Rpc.Failure'
            - '    , user : User'
            - '    }'
            - ""
            - 'defaultAuthResponse : AuthResponse'
            - defaultAuthResponse =
            - '    { failure = Rpc.defaultFailure'
            - '    , user = defaultUser'
            - '    }'
            - ""
            - 'encodeAuthResponse : AuthResponse -> E.Value'
            - encodeAuthResponse obj =
            - '    E.object'
            - '        [ ( "failure", Rpc.encodeFailure obj.failure )'
            - '        , ( "user", encodeUser obj.user )'
            - '        ]'
            - ""
            - 'decodeAuthResponse : D.Decoder AuthResponse'
            - decodeAuthResponse =
            - '    D.map2 AuthResponse'
            - '                (Rpc.decodeFailure'
            - '                    |> D.field "failure"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (Rpc.defaultFailure))'
            - '                )'
            - '                (decodeUser'
            - '                    |> D.field "user"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (defaultUser))'
            - '                )'
            - '    '
            - ""
            - type alias User =
            - '    { email : String'
            - '    , metadata : Dict (String) (String)'
            - '    , username : String'
            - '    }'
            - ""
            - 'defaultUser : User'
            - defaultUser =
            - '    { email = ""'
            - '    , metadata = Dict.empty'
            - '    , username = ""'
            - '    }'
            - ""
            - 'encodeUser : User -> E.Value'
            - encodeUser obj =
            - '    E.object'
            - '        [ ( "email", E.string obj.email )'
            - '        , ( "metadata", E.dict (identity) (E.string) obj.metadata )'
            - '        , ( "username", E.string obj.username )'
            - '        ]'
            - ""
            - 'decodeUser : D.Decoder User'
            - decodeUser =
            - '    D.map3 User'
            - '                (D.string'
            - '                    |> D.field "email"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '                (D.dict (D.string)'
            - '                    |> D.field "metadata"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (Dict.empty))'
            - '                )'
            - '                (D.string'
            - '                    |> D.field "username"'
            - '                    |> D.maybe'
            - '                    |> D.map (Maybe.withDefault (""))'
            - '                )'
            - '    '
            - '-----END Auth.elm-----'
            - ""
- name: ./smoketests.yml \ Generators \ Elm \ Types
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*/*.elm
          data: []
    - command: $(go env GOPATH)/bin/rpc -gen elm -out /tmp/rpc/elm all-types.rpc
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/elm/*.elm
          data:
            - '-----BEGIN Rpc.elm-----'
            - module Rpc exposing (..)
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Http
            - import Json.Decode as D
            - import Json.Encode as E
            - import Dict exposing (Dict)
            - import Task exposing (Task)
            - import Time exposing (Posix)
            - import Bytes exposing (Bytes)
            - import Bytes.Encode
            - import RpcUtil exposing (Config, RpcError, RpcResult, decodeApply, fromHttpResult)
            - ""
            - ""
            - ""
            - type alias Containers =
            - '    { ellijList : List (Int)'
            - '    , ellijMap : Dict (String) (Int)'
            - '    , espressoList : List (Float)'
            - '    , espressoMap : Dict (String) (Float)'
            - '    , ingCastleList : List (Float)'
            - '    , ingCastleMap : Dict (String) (Float)'
            - '    , islandList : List (Int)'
            - '    , islandMap : Dict (String) (Int)'
            - '    , ofCharactersList : List (String)'
            - '    , ofCharactersMap : Dict (String) (String)'
            - '    , ologyList : List (())'
            - '    , ologyMap : Dict (String) (())'
            - '    , soongTypeList : List (String)'
            - '    , soongTypeMap : Dict (String) (String)'
            - '    , travellingList : List (Posix)'
            - '    , travellingMap : Dict (String) (Posix)'
            - '    , truthOrDareList : List (Bool)'
            - '    , truthOrDareMap : Dict (String) (Bool)'
            - '    }'
            - ""
            - 'defaultContainers : Containers'
            - defaultContainers =
            - '    { ellijList = []'
            - '    , ellijMap = Dict.empty'
            - '    , espressoList = []'
            - '    , espressoMap = Dict.empty'
            - '    , ingCastleList = []'
            - '    , ingCastleMap = Dict.empty'
            - '    , islandList = []'
            - '    , islandMap = Dict.empty'
            - '    , ofCharactersList = []'
            - '    , ofCharactersMap = Dict.empty'
            - '    , ologyList = []'
            - '    , ologyMap = Dict.empty'
            - '    , soongTypeList = []'
            - '    , soongTypeMap = Dict.empty'
            - '    , travellingList = []'
            - '    , travellingMap = Dict.empty'
            - '    , truthOrDareList = []'
            - '    , truthOrDareMap = Dict.empty'
            - '    }'
            - ""
            - 'encodeContainers : Containers -> E.Value'
            - encodeContainers obj =
            - '    E.object'
            - '        [ ( "ellijList", E.list (E.int) obj.ellijList )'
            - '        , ( "ellijMap", E.dict (identity) (E.int) obj.ellijMap )'
            - '        , ( "espressoList", E.list (E.float) obj.espressoList )'
            - '        , ( "espressoMap", E.dict (identity) (E.float) obj.espressoMap
              )'
            - '        , ( "ingCastleList", E.list (E.float) obj.ingCastleList )'
            - '        , ( "ingCastleMap", E.dict (identity) (E.float) obj.ingCastleMap
              )'
            - '        , ( "islandList", E.list (E.int) obj.islandList )'
            - '        , ( "islandMap", E.dict (identity) (E.int) obj.islandMap )'
            - '        , ( "ofCharactersList", E.list (E.string) obj.ofCharactersList
              )'
            - '        , ( "ofCharactersMap", E.dict (identity) (E.string) obj.ofCharactersMap
              )'
            - '        , ( "ologyList", E.list ((\_ -> E.object [])) obj.ologyList
              )'
            - '        , ( "ologyMap", E.dict (identity) ((\_ -> E.object [])) obj.ologyMap
              )'
            - '        , ( "soongTypeList", E.list (E.string) obj.soongTypeList )'
            - '        , ( "soongTypeMap", E.dict (identity) (E.string) obj.soongTypeMap
              )'
            - '        , ( "travellingList", E.list ((Time.posixToMillis >> toFloat
              >> (\f -> f/1000.0) >> E.float)) obj.travellingList )'
            - '        , ( "travellingMap", E.dict (identity) ((Time.posixToMillis
              >> toFloat >> (\f -> f/1000.0) >> E.float)) obj.travellingMap )'
            - '        , ( "truthOrDareList", E.list (E.bool) obj.truthOrDareList
              )'
            - '        , ( "truthOrDareMap", E.dict (identity) (E.bool) obj.truthOrDareMap
              )'
            - '        ]'
            - ""
            - 'decodeContainers : D.Decoder Containers'
            - decodeContainers =
            - '    D.succeed Containers'
            - '            |> (D.list (D.int)'
            - '                |> D.field "ellijList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.int)'
            - '                |> D.field "ellijMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.float)'
            - '                |> D.field "espressoList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.float)'
            - '                |> D.field "espressoMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.float)'
            - '                |> D.field "ingCastleList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.float)'
            - '                |> D.field "ingCastleMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.int)'
            - '                |> D.field "islandList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.int)'
            - '                |> D.field "islandMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.string)'
            - '                |> D.field "ofCharactersList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.string)'
            - '                |> D.field "ofCharactersMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.map (\_ -> ()) D.value)'
            - '                |> D.field "ologyList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.map (\_ -> ()) D.value)'
            - '                |> D.field "ologyMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.string)'
            - '                |> D.field "soongTypeList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.string)'
            - '                |> D.field "soongTypeMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list ((D.map ((\f -> f * 1000.0) >> round >> Time.millisToPosix)
              D.float))'
            - '                |> D.field "travellingList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict ((D.map ((\f -> f * 1000.0) >> round >> Time.millisToPosix)
              D.float))'
            - '                |> D.field "travellingMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '            |> (D.list (D.bool)'
            - '                |> D.field "truthOrDareList"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '                |> decodeApply)'
            - '            |> (D.dict (D.bool)'
            - '                |> D.field "truthOrDareMap"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Dict.empty))'
            - '                |> decodeApply)'
            - '    '
            - ""
            - type alias Things =
            - '    { ellij : Int'
            - '    , espresso : Float'
            - '    , ingCastle : Float'
            - '    , island : Int'
            - '    , ofCharacters : String'
            - '    , ology : ()'
            - '    , soongType : String'
            - '    , travelling : Posix'
            - '    , truthOrDare : Bool'
            - '    }'
            - ""
            - 'defaultThings : Things'
            - defaultThings =
            - '    { ellij = 0'
            - '    , espresso = 0.0'
            - '    , ingCastle = 0.0'
            - '    , island = 0'
            - '    , ofCharacters = ""'
            - '    , ology = '
            - '    , soongType = ""'
            - '    , travelling = Time.millisToPosix 0'
            - '    , truthOrDare = False'
            - '    }'
            - ""
            - 'encodeThings : Things -> E.Value'
            - encodeThings obj =
            - '    E.object'
            - '        [ ( "ellij", E.int obj.ellij )'
            - '        , ( "espresso", E.float obj.espresso )'
            - '        , ( "ingCastle", E.float obj.ingCastle )'
            - '        , ( "island", E.int obj.island )'
            - '        , ( "ofCharacters", E.string obj.ofCharacters )'
            - '        , ( "ology", (\_ -> E.object []) obj.ology )'
            - '        , ( "soongType", E.string obj.soongType )'
            - '        , ( "travelling", (Time.posixToMillis >> toFloat >> (\f ->
              f/1000.0) >> E.float) obj.travelling )'
            - '        , ( "truthOrDare", E.bool obj.truthOrDare )'
            - '        ]'
            - ""
            - 'decodeThings : D.Decoder Things'
            - decodeThings =
            - '    D.succeed Things'
            - '            |> (D.int'
            - '                |> D.field "ellij"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (0))'
            - '                |> decodeApply)'
            - '            |> (D.float'
            - '                |> D.field "espresso"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (0.0))'
            - '                |> decodeApply)'
            - '            |> (D.float'
            - '                |> D.field "ingCastle"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (0.0))'
            - '                |> decodeApply)'
            - '            |> (D.int'
            - '                |> D.field "island"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (0))'
            - '                |> decodeApply)'
            - '            |> (D.string'
            - '                |> D.field "ofCharacters"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> (D.map (\_ -> ()) D.value'
            - '                |> D.field "ology"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ())'
            - '                |> decodeApply)'
            - '            |> (D.string'
            - '                |> D.field "soongType"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (""))'
            - '                |> decodeApply)'
            - '            |> ((D.map ((\f -> f * 1000.0) >> round >> Time.millisToPosix)
              D.float)'
            - '                |> D.field "travelling"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (Time.millisToPosix 0))'
            - '                |> decodeApply)'
            - '            |> (D.bool'
            - '                |> D.field "truthOrDare"'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (False))'
            - '                |> decodeApply)'
            - '    '
            - ""
            - ""
            - ""
            - type Enums
            - '    = The'
            - '    | Quick'
            - '    | Brown'
            - '    | Fox'
            - '    | Jumps'
            - '    | Over'
            - '    | The'
            - '    | Lazy'
            - '    | Dog'
            - ""
            - 'allEnums : List Enums'
            - allEnums =
            - '    [ The'
            - '    , Quick'
            - '    , Brown'
            - '    , Fox'
            - '    , Jumps'
            - '    , Over'
            - '    , The'
            - '    , Lazy'
            - '    , Dog'
            - '    ]'
            - ""
            - 'pairsOfEnums : List ( String, Enums )'
            - pairsOfEnums =
            - '    [ ( "the", The )'
            - '    , ( "quick", Quick )'
            - '    , ( "brown", Brown )'
            - '    , ( "fox", Fox )'
            - '    , ( "jumps", Jumps )'
            - '    , ( "over", Over )'
            - '    , ( "the", The )'
            - '    , ( "lazy", Lazy )'
            - '    , ( "dog", Dog )'
            - '    ]'
            - ""
            - 'titlePairsOfEnums : List ( String, String )'
            - titlePairsOfEnums =
            - '    [ ( "the", "The" )'
            - '    , ( "quick", "Quick" )'
            - '    , ( "brown", "Brown" )'
            - '    , ( "fox", "Fox" )'
            - '    , ( "jumps", "Jumps" )'
            - '    , ( "over", "Over" )'
            - '    , ( "the", "The" )'
            - '    , ( "lazy", "Lazy" )'
            - '    , ( "dog", "Dog" )'
            - '    ]'
            - ""
            - 'stringToEnums : String -> Maybe Enums'
            - stringToEnums str =
            - '    case str of'
            - '        "the" ->'
            - '            Just The'
            - '        "quick" ->'
            - '            Just Quick'
            - '        "brown" ->'
            - '            Just Brown'
            - '        "fox" ->'
            - '            Just Fox'
            - '        "jumps" ->'
            - '            Just Jumps'
            - '        "over" ->'
            - '            Just Over'
            - '        "the" ->'
            - '            Just The'
            - '        "lazy" ->'
            - '            Just Lazy'
            - '        "dog" ->'
            - '            Just Dog'
            - '        _ ->'
            - '            Nothing'
            - ""
            - 'stringFromEnums : Enums -> String'
            - stringFromEnums v =
            - '    case v of'
            - '        The ->'
            - '            "the"'
            - '        Quick ->'
            - '            "quick"'
            - '        Brown ->'
            - '            "brown"'
            - '        Fox ->'
            - '            "fox"'
            - '        Jumps ->'
            - '            "jumps"'
            - '        Over ->'
            - '            "over"'
            - '        The ->'
            - '            "the"'
            - '        Lazy ->'
            - '            "lazy"'
            - '        Dog ->'
            - '            "dog"'
            - ""
            - 'titleStringFromEnums : Enums -> String'
            - titleStringFromEnums v =
            - '    case v of'
            - '        The ->'
            - '            "The"'
            - '        Quick ->'
            - '            "Quick"'
            - '        Brown ->'
            - '            "Brown"'
            - '        Fox ->'
            - '            "Fox"'
            - '        Jumps ->'
            - '            "Jumps"'
            - '        Over ->'
            - '            "Over"'
            - '        The ->'
            - '            "The"'
            - '        Lazy ->'
            - '            "Lazy"'
            - '        Dog ->'
            - '            "Dog"'
            - ""
            - defaultEnums =
            - '    The'
            - ""
            - 'encodeEnums : Enums -> E.Value'
            - encodeEnums =
            - '    stringFromEnums >> E.string'
            - ""
            - 'decodeEnums : D.Decoder Enums'
            - decodeEnums =
            - '    D.string'
            - '        |> D.map stringToEnums'
            - '        |> D.map (Maybe.withDefault defaultEnums)'
            - ""
            - ""
            - ""
            - type alias InputForAllThe =
            - '    (Things)'
            - ""
            - 'encodeInputForAllThe : InputForAllThe -> E.Value'
            - encodeInputForAllThe
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeThings arg0'
            - '            ]'
            - ""
            - 'decodeInputForAllThe : D.Decoder InputForAllThe'
            - decodeInputForAllThe =
            - '        decodeThings'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultThings))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForAllThe =
            - '    (Things)'
            - ""
            - 'encodeOutputForAllThe : OutputForAllThe -> E.Value'
            - encodeOutputForAllThe
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeThings arg0'
            - '            ]'
            - ""
            - 'decodeOutputForAllThe : D.Decoder OutputForAllThe'
            - decodeOutputForAllThe =
            - '        decodeThings'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultThings))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForCatIn =
            - '    (Containers)'
            - ""
            - 'encodeInputForCatIn : InputForCatIn -> E.Value'
            - encodeInputForCatIn
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeContainers arg0'
            - '            ]'
            - ""
            - 'decodeInputForCatIn : D.Decoder InputForCatIn'
            - decodeInputForCatIn =
            - '        decodeContainers'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultContainers))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias OutputForCatIn =
            - '    (Containers)'
            - ""
            - 'encodeOutputForCatIn : OutputForCatIn -> E.Value'
            - encodeOutputForCatIn
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ encodeContainers arg0'
            - '            ]'
            - ""
            - 'decodeOutputForCatIn : D.Decoder OutputForCatIn'
            - decodeOutputForCatIn =
            - '        decodeContainers'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault (defaultContainers))'
            - '            |> D.map (\a -> (a))'
            - ""
            - type alias InputForMixEmUp =
            - '    (Things, Containers, List (Things))'
            - ""
            - 'encodeInputForMixEmUp : InputForMixEmUp -> E.Value'
            - encodeInputForMixEmUp
            - '    (arg0,arg1,arg2) ='
            - '        E.list (identity)'
            - '            [ encodeThings arg0'
            - '            , encodeContainers arg1'
            - '            , E.list (encodeThings) arg2'
            - '            ]'
            - ""
            - 'decodeInputForMixEmUp : D.Decoder InputForMixEmUp'
            - decodeInputForMixEmUp =
            - '        D.map3 (\arg0 arg1 arg2 -> (arg0, arg1, arg2))'
            - '            (decodeThings'
            - '                |> D.index 0'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (defaultThings))'
            - '            )'
            - '            (decodeContainers'
            - '                |> D.index 1'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault (defaultContainers))'
            - '            )'
            - '            (D.list (decodeThings)'
            - '                |> D.index 2'
            - '                |> D.maybe'
            - '                |> D.map (Maybe.withDefault ([]))'
            - '            )'
            - '    '
            - ""
            - type alias OutputForMixEmUp =
            - '    (())'
            - ""
            - 'encodeOutputForMixEmUp : OutputForMixEmUp -> E.Value'
            - encodeOutputForMixEmUp
            - '    (arg0) ='
            - '        E.list (identity)'
            - '            [ (\_ -> E.object []) arg0'
            - '            ]'
            - ""
            - 'decodeOutputForMixEmUp : D.Decoder OutputForMixEmUp'
            - decodeOutputForMixEmUp =
            - '        D.map (\_ -> ()) D.value'
            - '            |> D.index 0'
            - '            |> D.maybe'
            - '            |> D.map (Maybe.withDefault ())'
            - '            |> D.map (\a -> (a))'
            - ""
            - ""
            - ""
            - 'callAllTheTask : Config -> InputForAllThe -> Task RpcError OutputForAllThe'
            - callAllTheTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForAllThe input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForAllThe'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/AllThe"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callAllThe : Config -> InputForAllThe -> (RpcResult OutputForAllThe
              -> a) -> Cmd a'
            - callAllThe config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForAllThe input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForAllThe)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/AllThe"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callCatInTask : Config -> InputForCatIn -> Task RpcError OutputForCatIn'
            - callCatInTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForCatIn input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForCatIn'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/CatIn"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callCatIn : Config -> InputForCatIn -> (RpcResult OutputForCatIn ->
              a) -> Cmd a'
            - callCatIn config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForCatIn input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForCatIn)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/CatIn"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - ""
            - 'callMixEmUpTask : Config -> InputForMixEmUp -> Task RpcError OutputForMixEmUp'
            - callMixEmUpTask config input =
            - '    let'
            - '        body ='
            - '            Http.jsonBody (encodeInputForMixEmUp input)'
            - ""
            - '        resolver ='
            - '            RpcUtil.resolver decodeOutputForMixEmUp'
            - '    in'
            - '    Http.task'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/MixEmUp"'
            - '        , body = body'
            - '        , resolver = resolver'
            - '        , timeout = Nothing'
            - '        }'
            - ""
            - ""
            - 'callMixEmUp : Config -> InputForMixEmUp -> (RpcResult OutputForMixEmUp
              -> a) -> Cmd a'
            - callMixEmUp config input mapResult =
            - '    let'
            - '        body = Http.jsonBody (encodeInputForMixEmUp input)'
            - '        expect = Http.expectJson (fromHttpResult >> mapResult) (RpcUtil.decoder
              decodeOutputForMixEmUp)'
            - '    in'
            - '    Http.request'
            - '        { method = "POST"'
            - '        , headers = config.headers'
            - '        , url = config.baseUrl ++ "/rpc/MixEmUp"'
            - '        , body = body'
            - '        , expect = expect'
            - '        , timeout = Nothing'
            - '        , tracker = Nothing'
            - '        }'
            - '-----END Rpc.elm-----'
            - ""
            - '-----BEGIN RpcUtil.elm-----'
            - module RpcUtil exposing
            - '    ( Config'
            - '    , RpcError(..)'
            - '    , RpcResult'
            - '    , configDecoder'
            - '    , decodeApply'
            - '    , decodeString'
            - '    , decodeValue'
            - '    , decoder'
            - '    , errorToString'
            - '    , fromHttpResult'
            - '    , map'
            - '    , resolver'
            - '    )'
            - ""
            - -- <auto-generated />
            - -- @generated by github.com/chakrit/rpc
            - ""
            - import Array exposing (Array)
            - import Bitwise as Bits
            - import Bytes exposing (Bytes)
            - import Bytes.Decode as BytesDec
            - import Bytes.Encode as BytesEnc
            - import Dict exposing (Dict)
            - import Http exposing (Error(..), Resolver, Response(..))
            - import Json.Decode as JsonDec
            - ""
            - ""
            - type alias Config =
            - '    { baseUrl : String'
            - '    , headers : List Http.Header'
            - '    }'
            - ""
            - ""
            - 'configDecoder : JsonDec.Decoder Config'
            - configDecoder =
            - '    let'
            - '        mapHeader : Array String -> Http.Header'
            - '        mapHeader arr ='
            - '            let'
            - '                header ='
            - '                    Array.get 0 arr |> Maybe.withDefault ""'
            - ""
            - '                content ='
            - '                    Array.get 1 arr |> Maybe.withDefault ""'
            - '            in'
            - '            Http.header header content'
            - ""
            - '        mapHeaderArray : Array (Array String) -> List Http.Header'
            - '        mapHeaderArray arr ='
            - '            arr |> Array.map mapHeader |> Array.toList'
            - '    in'
            - '    JsonDec.map2 Config'
            - '        (JsonDec.field "baseUrl" <| JsonDec.string)'
            - '        (JsonDec.field "headers" <| JsonDec.map mapHeaderArray (JsonDec.array
              (JsonDec.array JsonDec.string)))'
            - ""
            - ""
            - 'decodeApply : JsonDec.Decoder a -> JsonDec.Decoder (a -> b) -> JsonDec.Decoder
              b'
            - decodeApply fieldDec partial =
            - '    JsonDec.andThen (\p -> JsonDec.map p fieldDec) partial'
            - ""
            - ""
            - type RpcError
            - '    = HttpError Http.Error'
            - '    | JsonError JsonDec.Error'
            - '    | ApiError String'
            - ""
            - ""
            - type alias RpcResult a =
            - '    Result RpcError a'
            - ""
            - ""
            - 'fromHttpResult : Result Http.Error (RpcResult a) -> RpcResult a'
            - fromHttpResult httpResult =
            - '    case httpResult of'
            - '        Err err ->'
            - '            Err (HttpError err)'
            - ""
            - '        Ok result ->'
            - '            -- unwrap inner result'
            - '            result'
            - ""
            - ""
            - 'errorToString : RpcError -> String'
            - errorToString httpErr =
            - '    case httpErr of'
            - '        HttpError (BadUrl str) ->'
            - '            "Bad URL: " ++ str'
            - ""
            - '        HttpError Timeout ->'
            - '            "Network Timeout"'
            - ""
            - '        HttpError NetworkError ->'
            - '            "Network Error"'
            - ""
            - '        HttpError (BadStatus code) ->'
            - '            "Bad Status Code: " ++ String.fromInt code'
            - ""
            - '        HttpError (BadBody str) ->'
            - '            "Malformed Response: " ++ str'
            - ""
            - '        JsonError err ->'
            - '            "JSON Error: " ++ JsonDec.errorToString err'
            - ""
            - '        ApiError str ->'
            - '            str'
            - ""
            - ""
            - 'resolver : JsonDec.Decoder a -> Resolver RpcError a'
            - resolver decoder_ =
            - '    Http.stringResolver'
            - '        (\resp ->'
            - '            case resp of'
            - '                BadUrl_ s ->'
            - '                    Err (HttpError (BadUrl s))'
            - ""
            - '                Timeout_ ->'
            - '                    Err (HttpError Timeout)'
            - ""
            - '                NetworkError_ ->'
            - '                    Err (HttpError NetworkError)'
            - ""
            - '                BadStatus_ metadata _ ->'
            - '                    Err (HttpError (BadStatus metadata.statusCode))'
            - ""
            - '                GoodStatus_ metadata str ->'
            - '                    decodeString (decoder decoder_) str'
            - '        )'
            - ""
            - ""
            - 'map : (RpcError -> msg) -> (a -> msg) -> RpcResult a -> msg'
            - map errMap okMap result =
            - '    case result of'
            - '        Err err ->'
            - '            errMap err'
            - ""
            - '        Ok obj ->'
            - '            okMap obj'
            - ""
            - ""
            - 'decodeString : JsonDec.Decoder (RpcResult a) -> String -> RpcResult
              a'
            - decodeString decoder_ str =
            - '    case JsonDec.decodeString decoder_ str of'
            - '        Ok v ->'
            - '            -- unwrap inner Result'
            - '            v'
            - ""
            - '        Err err ->'
            - '            Err (JsonError err)'
            - ""
            - ""
            - 'decodeValue : JsonDec.Decoder (RpcResult a) -> JsonDec.Value -> RpcResult
              a'
            - decodeValue decoder_ value =
            - '    case JsonDec.decodeValue decoder_ value of'
            - '        Ok v ->'
            - '            -- unwrap inner Result'
            - '            v'
            - ""
            - '        Err err ->'
            - '            Err (JsonError err)'
            - ""
            - ""
            - 'decoder : JsonDec.Decoder a -> JsonDec.Decoder (RpcResult a)'
            - decoder returnDecoder =
            - '    let'
            - '        mapToResult : Maybe String -> a -> RpcResult a'
            - '        mapToResult err ret ='
            - '            case err of'
            - '                Just str ->'
            - '                    Err (ApiError str)'
            - ""
            - '                Nothing ->'
            - '                    Ok ret'
            - '    in'
            - '    JsonDec.map2 mapToResult'
            - '        (JsonDec.field "error" (JsonDec.maybe JsonDec.string))'
            - '        (JsonDec.field "returns" returnDecoder)'
            - '-----END RpcUtil.elm-----'
            - ""
        - name: /tmp/rpc/elm/*/*.elm
          data: []
        - name: /tmp/rpc/elm/*/*/*.elm
          data: []
- name: ./smoketests.yml \ Generators \ Go
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data: []
        - name: /tmp/rpc/go/*/*.go
          data: []
        - name: /tmp/rpc/go/*/*/*.go
          data: []
- name: ./smoketests.yml \ Generators \ Go \ Simple
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data: []
        - name: /tmp/rpc/go/*/*.go
          data: []
        - name: /tmp/rpc/go/*/*/*.go
          data: []
    - command: $(go env GOPATH)/bin/rpc -gen go -out /tmp/rpc/go todo-simple.rpc
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data:
            - '-----BEGIN rpc.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: go.example.com/rpc'
            - package minitodo
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"math\""
            - ""
            - "\ttime \"time\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_                 = json.Marshal"
            - "\t_                 = math.Pi"
            - )
            - ""
            - type Failure struct {
            - "\tCode        string `json:\"code\" yaml:\"code\" db:\"code\"`"
            - "\tDescription string `json:\"description\" yaml:\"description\" db:\"description\"`"
            - '}'
            - ""
            - func (obj *Failure) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tCode        string `json:\"code\"`"
            - "\t\tDescription string `json:\"description\"`"
            - "\t}{"
            - "\t\tCode:        (obj.Code),"
            - "\t\tDescription: (obj.Description),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *Failure) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tCode        string `json:\"code\"`"
            - "\t\tDescription string `json:\"description\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Code = (inobj.Code)"
            - "\tobj.Description = (inobj.Description)"
            - "\treturn nil"
            - '}'
            - ""
            - type TodoItem struct {
            - "\tCompleted   bool      `json:\"completed\" yaml:\"completed\" db:\"completed\"`"
            - "\tCtime       time.Time `json:\"ctime\" yaml:\"ctime\" db:\"ctime\"`"
            - "\tDescription string    `json:\"description\" yaml:\"description\"
              db:\"description\"`"
            - "\tMetadata    []byte    `json:\"metadata\" yaml:\"metadata\" db:\"metadata\"`"
            - "\tUuid        string    `json:\"uuid\" yaml:\"uuid\" db:\"uuid\"`"
            - '}'
            - ""
            - func (obj *TodoItem) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tCompleted   bool    `json:\"completed\"`"
            - "\t\tCtime       float64 `json:\"ctime\"`"
            - "\t\tDescription string  `json:\"description\"`"
            - "\t\tMetadata    []byte  `json:\"metadata\"`"
            - "\t\tUuid        string  `json:\"uuid\"`"
            - "\t}{"
            - "\t\tCompleted: (obj.Completed),"
            - "\t\tCtime: (func(t time.Time) float64 {"
            - "\t\t\tsec, nsec := t.Unix(), t.Nanosecond()"
            - "\t\t\treturn float64(sec) + (float64(nsec) / float64(time.Second))"
            - "\t\t})(obj.Ctime),"
            - "\t\tDescription: (obj.Description),"
            - "\t\tMetadata:    (obj.Metadata),"
            - "\t\tUuid:        (obj.Uuid),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *TodoItem) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tCompleted   bool    `json:\"completed\"`"
            - "\t\tCtime       float64 `json:\"ctime\"`"
            - "\t\tDescription string  `json:\"description\"`"
            - "\t\tMetadata    []byte  `json:\"metadata\"`"
            - "\t\tUuid        string  `json:\"uuid\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Completed = (inobj.Completed)"
            - "\tobj.Ctime = (func(t float64) time.Time {"
            - "\t\tfsec, fnsec := math.Modf(t)"
            - "\t\tsec, nsec := int64(fsec), int64(math.Round(fnsec*float64(time.Second)))"
            - "\t\treturn time.Unix(sec, nsec)"
            - "\t})(inobj.Ctime)"
            - "\tobj.Description = (inobj.Description)"
            - "\tobj.Metadata = (inobj.Metadata)"
            - "\tobj.Uuid = (inobj.Uuid)"
            - "\treturn nil"
            - '}'
            - ""
            - type Interface interface {
            - "\tDelete(context.Context, string) (*TodoItem, error,"
            - "\t)"
            - "\tGet(context.Context, string) (*TodoItem, error,"
            - "\t)"
            - "\tList(context.Context) ([]*TodoItem, error,"
            - "\t)"
            - "\tPut(context.Context, *TodoItem) (*TodoItem, error,"
            - "\t)"
            - '}'
            - '-----END rpc.go-----'
            - ""
        - name: /tmp/rpc/go/*/*.go
          data:
            - '-----BEGIN client.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: go.example.com/rpc/client'
            - package client
            - ""
            - import (
            - "\t\"bytes\""
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"net/http\""
            - "\t\"time\""
            - ""
            - "\trpc_root \"go.example.com/rpc\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_ time.Time       = time.Time{}"
            - )
            - ""
            - // go.example.com/rpc
            - var _ rpc_root.Interface = Client_rpc_root{}
            - ""
            - type Client_rpc_root struct {
            - "\t*Client"
            - '}'
            - ""
            - func (c *Client_rpc_root) initialize(client *Client) {
            - "\tc.Client = client"
            - '}'
            - ""
            - func (c Client_rpc_root) Delete(
            - "\tctx context.Context,"
            - "\targ0 string,"
            - ) (
            - "\tout0 *rpc_root.TodoItem,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/minitodo/Delete\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_root) Get(
            - "\tctx context.Context,"
            - "\targ0 string,"
            - ) (
            - "\tout0 *rpc_root.TodoItem,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/minitodo/Get\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_root) List(
            - "\tctx context.Context,"
            - ) (
            - "\tout0 []*rpc_root.TodoItem,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/minitodo/List\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_root) Put(
            - "\tctx context.Context,"
            - "\targ0 *rpc_root.TodoItem,"
            - ) (
            - "\tout0 *rpc_root.TodoItem,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/minitodo/Put\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - ""
            - type Result struct {
            - "\tError   error         `json:\"error\"`"
            - "\tReturns []interface{} `json:\"returns\"`"
            - '}'
            - ""
            - type Client struct {
            - "\tOptions"
            - "\tClient_rpc_root"
            - ""
            - "\tHTTPClient *http.Client"
            - '}'
            - ""
            - type Options struct {
            - "\tAddr string"
            - '}'
            - ""
            - func New(opts *Options) *Client {
            - "\tclient := &Client{"
            - "\t\tOptions:         *opts,"
            - "\t\tClient_rpc_root: Client_rpc_root{},"
            - "\t\tHTTPClient:      &http.Client{},"
            - "\t}"
            - "\tclient.Client_rpc_root.initialize(client)"
            - "\treturn client"
            - '}'
            - '-----END client.go-----'
            - ""
            - '-----BEGIN server.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: go.example.com/rpc/server'
            - package server
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"net/http\""
            - ""
            - "\trpc_root \"go.example.com/rpc\""
            - )
            - ""
            - type Provider_rpc_root interface {
            - "\tProvide_rpc_root() rpc_root.Interface"
            - '}'
            - ""
            - type Result struct {
            - "\tError   error         `json:\"error\"`"
            - "\tReturns []interface{} `json:\"returns\"`"
            - '}'
            - ""
            - type Server struct {
            - "\toptions  Options"
            - "\tProvider Provider_rpc_root"
            - '}'
            - ""
            - type Options struct {
            - "\tAddr      string"
            - "\tCtxFilter func(req *http.Request, method string) context.Context"
            - "\tErrFilter func(req *http.Request, method string, err error) error"
            - "\tErrLog    func(req *http.Request, method string, err error)"
            - "\tFormatErr func(err error) string"
            - '}'
            - ""
            - func New(opts *Options) *Server {
            - "\tsrv := &Server{options: *opts}"
            - "\tif srv.options.CtxFilter == nil {"
            - "\t\tsrv.options.CtxFilter = func(req *http.Request, _ string) context.Context
              {"
            - "\t\t\treturn req.Context()"
            - "\t\t}"
            - "\t}"
            - "\tif srv.options.ErrFilter == nil {"
            - "\t\tsrv.options.ErrFilter = func(_ *http.Request, _ string, err error)
              error {"
            - "\t\t\treturn err"
            - "\t\t}"
            - "\t}"
            - "\treturn srv"
            - '}'
            - ""
            - func (s *Server) Listen() error {
            - "\treturn http.ListenAndServe(s.options.Addr, s.HTTPHandler())"
            - '}'
            - ""
            - func (s *Server) HTTPHandler() http.Handler {
            - "\tmux := http.NewServeMux()"
            - "\ts.register_rpc_root(mux, s.Provider)"
            - "\treturn mux"
            - '}'
            - ""
            - func (s *Server) register_rpc_root(
            - "\tmux *http.ServeMux,"
            - "\tprovider Provider_rpc_root,"
            - ) *http.ServeMux {
            - "\thandler := provider.Provide_rpc_root()"
            - ""
            - "\tmux.HandleFunc(\"/minitodo/Delete\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"minitodo/Delete\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 string"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_root.TodoItem"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Delete("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"minitodo/Delete\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"minitodo/Delete\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/minitodo/Get\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"minitodo/Get\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 string"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_root.TodoItem"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Get("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"minitodo/Get\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"minitodo/Get\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/minitodo/List\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"minitodo/List\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 []*rpc_root.TodoItem"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.List("
            - "\t\t\tctx)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"minitodo/List\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"minitodo/List\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/minitodo/Put\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"minitodo/Put\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 *rpc_root.TodoItem"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_root.TodoItem"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Put("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"minitodo/Put\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"minitodo/Put\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\treturn mux"
            - '}'
            - ""
            - func renderResult(options Options, resp http.ResponseWriter, status
              int, result *Result) {
            - "\tresp.Header().Set(\"Content-Type\", \"application/json\")"
            - ""
            - "\tshim := struct {"
            - "\t\tError   *string       `json:\"error\"`"
            - "\t\tReturns []interface{} `json:\"returns\"`"
            - "\t}{}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\tvar errstr string"
            - "\t\tif options.FormatErr != nil {"
            - "\t\t\terrstr = options.FormatErr(result.Error)"
            - "\t\t} else {"
            - "\t\t\terrstr = result.Error.Error()"
            - "\t\t}"
            - ""
            - "\t\tshim.Returns, shim.Error = nil, &errstr"
            - ""
            - "\t} else {"
            - "\t\tshim.Returns, shim.Error = result.Returns, nil"
            - "\t}"
            - ""
            - "\tbuf, err := json.Marshal(shim)"
            - "\tif err != nil {"
            - "\t\tresp.WriteHeader(500)"
            - "\t\t_, _ = resp.Write([]byte(`{\"error\":\"json processing error\",\"result\":null}`))"
            - "\t} else {"
            - "\t\tresp.WriteHeader(status)"
            - "\t\t_, _ = resp.Write(buf)"
            - "\t}"
            - '}'
            - '-----END server.go-----'
            - ""
        - name: /tmp/rpc/go/*/*/*.go
          data: []
- name: ./smoketests.yml \ Generators \ Go \ Complex
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data: []
        - name: /tmp/rpc/go/*/*.go
          data: []
        - name: /tmp/rpc/go/*/*/*.go
          data: []
    - command: $(go env GOPATH)/bin/rpc -gen go -out /tmp/rpc/go todo-complex.rpc
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data:
            - '-----BEGIN rpc.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: github.com/chakrit/rpc/examples'
            - package examples
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"math\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_                 = json.Marshal"
            - "\t_                 = math.Pi"
            - )
            - ""
            - type Failure struct {
            - "\tCode        string `json:\"code\" yaml:\"code\" db:\"code\"`"
            - "\tDescription string `json:\"description\" yaml:\"description\" db:\"description\"`"
            - '}'
            - ""
            - func (obj *Failure) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tCode        string `json:\"code\"`"
            - "\t\tDescription string `json:\"description\"`"
            - "\t}{"
            - "\t\tCode:        (obj.Code),"
            - "\t\tDescription: (obj.Description),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *Failure) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tCode        string `json:\"code\"`"
            - "\t\tDescription string `json:\"description\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Code = (inobj.Code)"
            - "\tobj.Description = (inobj.Description)"
            - "\treturn nil"
            - '}'
            - ""
            - type Interface interface {
            - '}'
            - '-----END rpc.go-----'
            - ""
        - name: /tmp/rpc/go/*/*.go
          data:
            - '-----BEGIN client.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: github.com/chakrit/rpc/examples/client'
            - package client
            - ""
            - import (
            - "\t\"bytes\""
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"net/http\""
            - "\t\"time\""
            - ""
            - "\trpc_root \"github.com/chakrit/rpc/examples\""
            - "\trpc_system \"github.com/chakrit/rpc/examples/system\""
            - "\trpc_system_auth \"github.com/chakrit/rpc/examples/system/auth\""
            - ""
            - "\trpc_todos \"github.com/chakrit/rpc/examples/todos\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_ time.Time       = time.Time{}"
            - )
            - ""
            - // github.com/chakrit/rpc/examples
            - var _ rpc_root.Interface = Client_rpc_root{}
            - ""
            - type Client_rpc_root struct {
            - "\t*Client"
            - "\tSystem Client_rpc_system"
            - "\tTodos  Client_rpc_todos"
            - '}'
            - ""
            - func (c *Client_rpc_root) initialize(client *Client) {
            - "\tc.Client = client"
            - "\tc.System = Client_rpc_system{}"
            - "\tc.System.initialize(client)"
            - "\tc.Todos = Client_rpc_todos{}"
            - "\tc.Todos.initialize(client)"
            - '}'
            - ""
            - // github.com/chakrit/rpc/examples/system
            - var _ rpc_system.Interface = Client_rpc_system{}
            - ""
            - type Client_rpc_system struct {
            - "\t*Client"
            - "\tAuth Client_rpc_system_auth"
            - '}'
            - ""
            - func (c *Client_rpc_system) initialize(client *Client) {
            - "\tc.Client = client"
            - "\tc.Auth = Client_rpc_system_auth{}"
            - "\tc.Auth.initialize(client)"
            - '}'
            - ""
            - func (c Client_rpc_system) Status(
            - "\tctx context.Context,"
            - ) (
            - "\tout0 *rpc_root.Failure,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/examples/system/Status\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - ""
            - // github.com/chakrit/rpc/examples/system/auth
            - var _ rpc_system_auth.Interface = Client_rpc_system_auth{}
            - ""
            - type Client_rpc_system_auth struct {
            - "\t*Client"
            - '}'
            - ""
            - func (c *Client_rpc_system_auth) initialize(client *Client) {
            - "\tc.Client = client"
            - '}'
            - ""
            - // github.com/chakrit/rpc/examples/todos
            - var _ rpc_todos.Interface = Client_rpc_todos{}
            - ""
            - type Client_rpc_todos struct {
            - "\t*Client"
            - '}'
            - ""
            - func (c *Client_rpc_todos) initialize(client *Client) {
            - "\tc.Client = client"
            - '}'
            - ""
            - func (c Client_rpc_todos) Delete(
            - "\tctx context.Context,"
            - "\targ0 string,"
            - ) (
            - "\tout0 *rpc_todos.Item,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/examples/todos/Delete\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_todos) Get(
            - "\tctx context.Context,"
            - "\targ0 string,"
            - ) (
            - "\tout0 *rpc_todos.Item,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/examples/todos/Get\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_todos) List(
            - "\tctx context.Context,"
            - ) (
            - "\tout0 []*rpc_todos.Item,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/examples/todos/List\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_todos) Put(
            - "\tctx context.Context,"
            - "\targ0 string,"
            - ) (
            - "\tout0 *rpc_todos.Item,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/examples/todos/Put\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - ""
            - type Result struct {
            - "\tError   error         `json:\"error\"`"
            - "\tReturns []interface{} `json:\"returns\"`"
            - '}'
            - ""
            - type Client struct {
            - "\tOptions"
            - "\tClient_rpc_root"
            - ""
            - "\tHTTPClient *http.Client"
            - '}'
            - ""
            - type Options struct {
            - "\tAddr string"
            - '}'
            - ""
            - func New(opts *Options) *Client {
            - "\tclient := &Client{"
            - "\t\tOptions:         *opts,"
            - "\t\tClient_rpc_root: Client_rpc_root{},"
            - "\t\tHTTPClient:      &http.Client{},"
            - "\t}"
            - "\tclient.Client_rpc_root.initialize(client)"
            - "\treturn client"
            - '}'
            - '-----END client.go-----'
            - ""
            - '-----BEGIN server.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: github.com/chakrit/rpc/examples/server'
            - package server
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"net/http\""
            - ""
            - "\trpc_root \"github.com/chakrit/rpc/examples\""
            - "\trpc_system \"github.com/chakrit/rpc/examples/system\""
            - "\trpc_system_auth \"github.com/chakrit/rpc/examples/system/auth\""
            - ""
            - "\trpc_todos \"github.com/chakrit/rpc/examples/todos\""
            - )
            - ""
            - type Provider_rpc_root interface {
            - "\tProvide_rpc_root() rpc_root.Interface"
            - ""
            - "\tProvider_rpc_system"
            - "\tProvider_rpc_todos"
            - '}'
            - ""
            - type Provider_rpc_system interface {
            - "\tProvide_rpc_system() rpc_system.Interface"
            - ""
            - "\tProvider_rpc_system_auth"
            - '}'
            - ""
            - type Provider_rpc_system_auth interface {
            - "\tProvide_rpc_system_auth() rpc_system_auth.Interface"
            - '}'
            - ""
            - type Provider_rpc_todos interface {
            - "\tProvide_rpc_todos() rpc_todos.Interface"
            - '}'
            - ""
            - type Result struct {
            - "\tError   error         `json:\"error\"`"
            - "\tReturns []interface{} `json:\"returns\"`"
            - '}'
            - ""
            - type Server struct {
            - "\toptions  Options"
            - "\tProvider Provider_rpc_root"
            - '}'
            - ""
            - type Options struct {
            - "\tAddr      string"
            - "\tCtxFilter func(req *http.Request, method string) context.Context"
            - "\tErrFilter func(req *http.Request, method string, err error) error"
            - "\tErrLog    func(req *http.Request, method string, err error)"
            - "\tFormatErr func(err error) string"
            - '}'
            - ""
            - func New(opts *Options) *Server {
            - "\tsrv := &Server{options: *opts}"
            - "\tif srv.options.CtxFilter == nil {"
            - "\t\tsrv.options.CtxFilter = func(req *http.Request, _ string) context.Context
              {"
            - "\t\t\treturn req.Context()"
            - "\t\t}"
            - "\t}"
            - "\tif srv.options.ErrFilter == nil {"
            - "\t\tsrv.options.ErrFilter = func(_ *http.Request, _ string, err error)
              error {"
            - "\t\t\treturn err"
            - "\t\t}"
            - "\t}"
            - "\treturn srv"
            - '}'
            - ""
            - func (s *Server) Listen() error {
            - "\treturn http.ListenAndServe(s.options.Addr, s.HTTPHandler())"
            - '}'
            - ""
            - func (s *Server) HTTPHandler() http.Handler {
            - "\tmux := http.NewServeMux()"
            - "\ts.register_rpc_root(mux, s.Provider)"
            - "\treturn mux"
            - '}'
            - ""
            - func (s *Server) register_rpc_root(
            - "\tmux *http.ServeMux,"
            - "\tprovider Provider_rpc_root,"
            - ) *http.ServeMux {
            - "\thandler := provider.Provide_rpc_root()"
            - ""
            - "\ts.register_rpc_system(mux, s.Provider)"
            - "\ts.register_rpc_todos(mux, s.Provider)"
            - "\treturn mux"
            - '}'
            - ""
            - func (s *Server) register_rpc_system(
            - "\tmux *http.ServeMux,"
            - "\tprovider Provider_rpc_system,"
            - ) *http.ServeMux {
            - "\thandler := provider.Provide_rpc_system()"
            - ""
            - "\tmux.HandleFunc(\"/examples/system/Status\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"examples/system/Status\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_root.Failure"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Status("
            - "\t\t\tctx)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"examples/system/Status\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"examples/system/Status\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\ts.register_rpc_system_auth(mux, s.Provider)"
            - "\treturn mux"
            - '}'
            - ""
            - func (s *Server) register_rpc_system_auth(
            - "\tmux *http.ServeMux,"
            - "\tprovider Provider_rpc_system_auth,"
            - ) *http.ServeMux {
            - "\thandler := provider.Provide_rpc_system_auth()"
            - ""
            - "\treturn mux"
            - '}'
            - ""
            - func (s *Server) register_rpc_todos(
            - "\tmux *http.ServeMux,"
            - "\tprovider Provider_rpc_todos,"
            - ) *http.ServeMux {
            - "\thandler := provider.Provide_rpc_todos()"
            - ""
            - "\tmux.HandleFunc(\"/examples/todos/Delete\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"examples/todos/Delete\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 string"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_todos.Item"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Delete("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"examples/todos/Delete\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"examples/todos/Delete\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/examples/todos/Get\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"examples/todos/Get\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 string"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_todos.Item"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Get("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"examples/todos/Get\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"examples/todos/Get\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/examples/todos/List\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"examples/todos/List\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 []*rpc_todos.Item"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.List("
            - "\t\t\tctx)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"examples/todos/List\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"examples/todos/List\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/examples/todos/Put\", func(resp http.ResponseWriter,
              req *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"examples/todos/Put\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 string"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_todos.Item"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.Put("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"examples/todos/Put\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"examples/todos/Put\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\treturn mux"
            - '}'
            - ""
            - func renderResult(options Options, resp http.ResponseWriter, status
              int, result *Result) {
            - "\tresp.Header().Set(\"Content-Type\", \"application/json\")"
            - ""
            - "\tshim := struct {"
            - "\t\tError   *string       `json:\"error\"`"
            - "\t\tReturns []interface{} `json:\"returns\"`"
            - "\t}{}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\tvar errstr string"
            - "\t\tif options.FormatErr != nil {"
            - "\t\t\terrstr = options.FormatErr(result.Error)"
            - "\t\t} else {"
            - "\t\t\terrstr = result.Error.Error()"
            - "\t\t}"
            - ""
            - "\t\tshim.Returns, shim.Error = nil, &errstr"
            - ""
            - "\t} else {"
            - "\t\tshim.Returns, shim.Error = result.Returns, nil"
            - "\t}"
            - ""
            - "\tbuf, err := json.Marshal(shim)"
            - "\tif err != nil {"
            - "\t\tresp.WriteHeader(500)"
            - "\t\t_, _ = resp.Write([]byte(`{\"error\":\"json processing error\",\"result\":null}`))"
            - "\t} else {"
            - "\t\tresp.WriteHeader(status)"
            - "\t\t_, _ = resp.Write(buf)"
            - "\t}"
            - '}'
            - '-----END server.go-----'
            - ""
            - '-----BEGIN rpc.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: github.com/chakrit/rpc/examples/system'
            - package system
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"math\""
            - ""
            - "\trpc_root \"github.com/chakrit/rpc/examples\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_                 = json.Marshal"
            - "\t_                 = math.Pi"
            - )
            - ""
            - type Interface interface {
            - "\tStatus(context.Context) (*rpc_root.Failure, error,"
            - "\t)"
            - '}'
            - '-----END rpc.go-----'
            - ""
            - '-----BEGIN rpc.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: github.com/chakrit/rpc/examples/todos'
            - package todos
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"math\""
            - ""
            - "\ttime \"time\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_                 = json.Marshal"
            - "\t_                 = math.Pi"
            - )
            - ""
            - type Item struct {
            - "\tAssignee    string    `json:\"assignee\" yaml:\"assignee\" db:\"assignee\"`"
            - "\tAuthor      string    `json:\"author\" yaml:\"author\" db:\"author\"`"
            - "\tCategory    string    `json:\"category\" yaml:\"category\" db:\"category\"`"
            - "\tCtime       time.Time `json:\"ctime\" yaml:\"ctime\" db:\"ctime\"`"
            - "\tDescription string    `json:\"description\" yaml:\"description\"
              db:\"description\"`"
            - "\tDueDate     time.Time `json:\"dueDate\" yaml:\"dueDate\" db:\"due_date\"`"
            - "\tID          string    `json:\"id\" yaml:\"id\" db:\"id\"`"
            - "\tState       State     `json:\"state\" yaml:\"state\" db:\"state\"`"
            - "\tTags        []string  `json:\"tags\" yaml:\"tags\" db:\"tags\"`"
            - '}'
            - ""
            - func (obj *Item) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tAssignee    string   `json:\"assignee\"`"
            - "\t\tAuthor      string   `json:\"author\"`"
            - "\t\tCategory    string   `json:\"category\"`"
            - "\t\tCtime       float64  `json:\"ctime\"`"
            - "\t\tDescription string   `json:\"description\"`"
            - "\t\tDueDate     float64  `json:\"dueDate\"`"
            - "\t\tID          string   `json:\"id\"`"
            - "\t\tState       string   `json:\"state\"`"
            - "\t\tTags        []string `json:\"tags\"`"
            - "\t}{"
            - "\t\tAssignee: (obj.Assignee),"
            - "\t\tAuthor:   (obj.Author),"
            - "\t\tCategory: (obj.Category),"
            - "\t\tCtime: (func(t time.Time) float64 {"
            - "\t\t\tsec, nsec := t.Unix(), t.Nanosecond()"
            - "\t\t\treturn float64(sec) + (float64(nsec) / float64(time.Second))"
            - "\t\t})(obj.Ctime),"
            - "\t\tDescription: (obj.Description),"
            - "\t\tDueDate: (func(t time.Time) float64 {"
            - "\t\t\tsec, nsec := t.Unix(), t.Nanosecond()"
            - "\t\t\treturn float64(sec) + (float64(nsec) / float64(time.Second))"
            - "\t\t})(obj.DueDate),"
            - "\t\tID:    (obj.ID),"
            - "\t\tState: (func(v State) string { return string(v) })(obj.State),"
            - "\t\tTags:  (obj.Tags),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *Item) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tAssignee    string   `json:\"assignee\"`"
            - "\t\tAuthor      string   `json:\"author\"`"
            - "\t\tCategory    string   `json:\"category\"`"
            - "\t\tCtime       float64  `json:\"ctime\"`"
            - "\t\tDescription string   `json:\"description\"`"
            - "\t\tDueDate     float64  `json:\"dueDate\"`"
            - "\t\tID          string   `json:\"id\"`"
            - "\t\tState       string   `json:\"state\"`"
            - "\t\tTags        []string `json:\"tags\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Assignee = (inobj.Assignee)"
            - "\tobj.Author = (inobj.Author)"
            - "\tobj.Category = (inobj.Category)"
            - "\tobj.Ctime = (func(t float64) time.Time {"
            - "\t\tfsec, fnsec := math.Modf(t)"
            - "\t\tsec, nsec := int64(fsec), int64(math.Round(fnsec*float64(time.Second)))"
            - "\t\treturn time.Unix(sec, nsec)"
            - "\t})(inobj.Ctime)"
            - "\tobj.Description = (inobj.Description)"
            - "\tobj.DueDate = (func(t float64) time.Time {"
            - "\t\tfsec, fnsec := math.Modf(t)"
            - "\t\tsec, nsec := int64(fsec), int64(math.Round(fnsec*float64(time.Second)))"
            - "\t\treturn time.Unix(sec, nsec)"
            - "\t})(inobj.DueDate)"
            - "\tobj.ID = (inobj.ID)"
            - "\tobj.State = (func(v string) State { return State(v) })(inobj.State)"
            - "\tobj.Tags = (inobj.Tags)"
            - "\treturn nil"
            - '}'
            - ""
            - type State string
            - ""
            - const (
            - "\tStateNew        = State(\"new\")"
            - "\tStateInProgress = State(\"in-progress\")"
            - "\tStateOverdue    = State(\"overdue\")"
            - "\tStateCompleted  = State(\"completed\")"
            - )
            - ""
            - type Interface interface {
            - "\tDelete(context.Context, string) (*Item, error,"
            - "\t)"
            - "\tGet(context.Context, string) (*Item, error,"
            - "\t)"
            - "\tList(context.Context) ([]*Item, error,"
            - "\t)"
            - "\tPut(context.Context, string) (*Item, error,"
            - "\t)"
            - '}'
            - '-----END rpc.go-----'
            - ""
        - name: /tmp/rpc/go/*/*/*.go
          data:
            - '-----BEGIN rpc.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: github.com/chakrit/rpc/examples/system/auth'
            - package auth
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"math\""
            - ""
            - "\trpc_root \"github.com/chakrit/rpc/examples\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_                 = json.Marshal"
            - "\t_                 = math.Pi"
            - )
            - ""
            - type AuthRequest struct {
            - "\tAuthData []byte `json:\"authData\" yaml:\"authData\" db:\"auth_data\"`"
            - "\tProvider string `json:\"provider\" yaml:\"provider\" db:\"provider\"`"
            - "\tUsername string `json:\"username\" yaml:\"username\" db:\"username\"`"
            - '}'
            - ""
            - func (obj *AuthRequest) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tAuthData []byte `json:\"authData\"`"
            - "\t\tProvider string `json:\"provider\"`"
            - "\t\tUsername string `json:\"username\"`"
            - "\t}{"
            - "\t\tAuthData: (obj.AuthData),"
            - "\t\tProvider: (obj.Provider),"
            - "\t\tUsername: (obj.Username),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *AuthRequest) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tAuthData []byte `json:\"authData\"`"
            - "\t\tProvider string `json:\"provider\"`"
            - "\t\tUsername string `json:\"username\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.AuthData = (inobj.AuthData)"
            - "\tobj.Provider = (inobj.Provider)"
            - "\tobj.Username = (inobj.Username)"
            - "\treturn nil"
            - '}'
            - ""
            - type AuthResponse struct {
            - "\tFailure *rpc_root.Failure `json:\"failure\" yaml:\"failure\" db:\"failure\"`"
            - "\tUser    *User             `json:\"user\" yaml:\"user\" db:\"user\"`"
            - '}'
            - ""
            - func (obj *AuthResponse) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tFailure *rpc_root.Failure `json:\"failure\"`"
            - "\t\tUser    *User             `json:\"user\"`"
            - "\t}{"
            - "\t\tFailure: (obj.Failure),"
            - "\t\tUser:    (obj.User),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *AuthResponse) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tFailure *rpc_root.Failure `json:\"failure\"`"
            - "\t\tUser    *User             `json:\"user\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Failure = (inobj.Failure)"
            - "\tobj.User = (inobj.User)"
            - "\treturn nil"
            - '}'
            - ""
            - type User struct {
            - "\tEmail    string            `json:\"email\" yaml:\"email\" db:\"email\"`"
            - "\tMetadata map[string]string `json:\"metadata\" yaml:\"metadata\" db:\"metadata\"`"
            - "\tUsername string            `json:\"username\" yaml:\"username\" db:\"username\"`"
            - '}'
            - ""
            - func (obj *User) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tEmail    string            `json:\"email\"`"
            - "\t\tMetadata map[string]string `json:\"metadata\"`"
            - "\t\tUsername string            `json:\"username\"`"
            - "\t}{"
            - "\t\tEmail:    (obj.Email),"
            - "\t\tMetadata: (obj.Metadata),"
            - "\t\tUsername: (obj.Username),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *User) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tEmail    string            `json:\"email\"`"
            - "\t\tMetadata map[string]string `json:\"metadata\"`"
            - "\t\tUsername string            `json:\"username\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Email = (inobj.Email)"
            - "\tobj.Metadata = (inobj.Metadata)"
            - "\tobj.Username = (inobj.Username)"
            - "\treturn nil"
            - '}'
            - ""
            - type Interface interface {
            - '}'
            - '-----END rpc.go-----'
            - ""
- name: ./smoketests.yml \ Generators \ Go \ Types
  commands:
    - command: rm -r /tmp/rpc >/dev/null 2>&1 || true
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data: []
        - name: /tmp/rpc/go/*/*.go
          data: []
        - name: /tmp/rpc/go/*/*/*.go
          data: []
    - command: $(go env GOPATH)/bin/rpc -gen go -out /tmp/rpc/go all-types.rpc
      checks:
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
        - name: /tmp/rpc/go/*.go
          data:
            - '-----BEGIN rpc.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: go.example.com/rpc'
            - package rpc
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"math\""
            - ""
            - "\ttime \"time\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_                 = json.Marshal"
            - "\t_                 = math.Pi"
            - )
            - ""
            - type Containers struct {
            - "\tEllijList        []int                `json:\"ellijList\" yaml:\"ellijList\"
              db:\"ellij_list\"`"
            - "\tEllijMap         map[string]int       `json:\"ellijMap\" yaml:\"ellijMap\"
              db:\"ellij_map\"`"
            - "\tEspressoList     []float64            `json:\"espressoList\" yaml:\"espressoList\"
              db:\"espresso_list\"`"
            - "\tEspressoMap      map[string]float64   `json:\"espressoMap\" yaml:\"espressoMap\"
              db:\"espresso_map\"`"
            - "\tIngCastleList    []float32            `json:\"ingCastleList\" yaml:\"ingCastleList\"
              db:\"ing_castle_list\"`"
            - "\tIngCastleMap     map[string]float32   `json:\"ingCastleMap\" yaml:\"ingCastleMap\"
              db:\"ing_castle_map\"`"
            - "\tIslandList       []int64              `json:\"islandList\" yaml:\"islandList\"
              db:\"island_list\"`"
            - "\tIslandMap        map[string]int64     `json:\"islandMap\" yaml:\"islandMap\"
              db:\"island_map\"`"
            - "\tOfCharactersList []string             `json:\"ofCharactersList\"
              yaml:\"ofCharactersList\" db:\"of_characters_list\"`"
            - "\tOfCharactersMap  map[string]string    `json:\"ofCharactersMap\" yaml:\"ofCharactersMap\"
              db:\"of_characters_map\"`"
            - "\tOlogyList        []struct{}           `json:\"ologyList\" yaml:\"ologyList\"
              db:\"ology_list\"`"
            - "\tOlogyMap         map[string]struct{}  `json:\"ologyMap\" yaml:\"ologyMap\"
              db:\"ology_map\"`"
            - "\tSoongTypeList    [][]byte             `json:\"soongTypeList\" yaml:\"soongTypeList\"
              db:\"soong_type_list\"`"
            - "\tSoongTypeMap     map[string][]byte    `json:\"soongTypeMap\" yaml:\"soongTypeMap\"
              db:\"soong_type_map\"`"
            - "\tTravellingList   []time.Time          `json:\"travellingList\" yaml:\"travellingList\"
              db:\"travelling_list\"`"
            - "\tTravellingMap    map[string]time.Time `json:\"travellingMap\" yaml:\"travellingMap\"
              db:\"travelling_map\"`"
            - "\tTruthOrDareList  []bool               `json:\"truthOrDareList\" yaml:\"truthOrDareList\"
              db:\"truth_or_dare_list\"`"
            - "\tTruthOrDareMap   map[string]bool      `json:\"truthOrDareMap\" yaml:\"truthOrDareMap\"
              db:\"truth_or_dare_map\"`"
            - '}'
            - ""
            - func (obj *Containers) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tEllijList        []int                `json:\"ellijList\"`"
            - "\t\tEllijMap         map[string]int       `json:\"ellijMap\"`"
            - "\t\tEspressoList     []float64            `json:\"espressoList\"`"
            - "\t\tEspressoMap      map[string]float64   `json:\"espressoMap\"`"
            - "\t\tIngCastleList    []float32            `json:\"ingCastleList\"`"
            - "\t\tIngCastleMap     map[string]float32   `json:\"ingCastleMap\"`"
            - "\t\tIslandList       []int64              `json:\"islandList\"`"
            - "\t\tIslandMap        map[string]int64     `json:\"islandMap\"`"
            - "\t\tOfCharactersList []string             `json:\"ofCharactersList\"`"
            - "\t\tOfCharactersMap  map[string]string    `json:\"ofCharactersMap\"`"
            - "\t\tOlogyList        []struct{}           `json:\"ologyList\"`"
            - "\t\tOlogyMap         map[string]struct{}  `json:\"ologyMap\"`"
            - "\t\tSoongTypeList    [][]byte             `json:\"soongTypeList\"`"
            - "\t\tSoongTypeMap     map[string][]byte    `json:\"soongTypeMap\"`"
            - "\t\tTravellingList   []time.Time          `json:\"travellingList\"`"
            - "\t\tTravellingMap    map[string]time.Time `json:\"travellingMap\"`"
            - "\t\tTruthOrDareList  []bool               `json:\"truthOrDareList\"`"
            - "\t\tTruthOrDareMap   map[string]bool      `json:\"truthOrDareMap\"`"
            - "\t}{"
            - "\t\tEllijList:        (obj.EllijList),"
            - "\t\tEllijMap:         (obj.EllijMap),"
            - "\t\tEspressoList:     (obj.EspressoList),"
            - "\t\tEspressoMap:      (obj.EspressoMap),"
            - "\t\tIngCastleList:    (obj.IngCastleList),"
            - "\t\tIngCastleMap:     (obj.IngCastleMap),"
            - "\t\tIslandList:       (obj.IslandList),"
            - "\t\tIslandMap:        (obj.IslandMap),"
            - "\t\tOfCharactersList: (obj.OfCharactersList),"
            - "\t\tOfCharactersMap:  (obj.OfCharactersMap),"
            - "\t\tOlogyList:        (obj.OlogyList),"
            - "\t\tOlogyMap:         (obj.OlogyMap),"
            - "\t\tSoongTypeList:    (obj.SoongTypeList),"
            - "\t\tSoongTypeMap:     (obj.SoongTypeMap),"
            - "\t\tTravellingList:   (obj.TravellingList),"
            - "\t\tTravellingMap:    (obj.TravellingMap),"
            - "\t\tTruthOrDareList:  (obj.TruthOrDareList),"
            - "\t\tTruthOrDareMap:   (obj.TruthOrDareMap),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *Containers) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tEllijList        []int                `json:\"ellijList\"`"
            - "\t\tEllijMap         map[string]int       `json:\"ellijMap\"`"
            - "\t\tEspressoList     []float64            `json:\"espressoList\"`"
            - "\t\tEspressoMap      map[string]float64   `json:\"espressoMap\"`"
            - "\t\tIngCastleList    []float32            `json:\"ingCastleList\"`"
            - "\t\tIngCastleMap     map[string]float32   `json:\"ingCastleMap\"`"
            - "\t\tIslandList       []int64              `json:\"islandList\"`"
            - "\t\tIslandMap        map[string]int64     `json:\"islandMap\"`"
            - "\t\tOfCharactersList []string             `json:\"ofCharactersList\"`"
            - "\t\tOfCharactersMap  map[string]string    `json:\"ofCharactersMap\"`"
            - "\t\tOlogyList        []struct{}           `json:\"ologyList\"`"
            - "\t\tOlogyMap         map[string]struct{}  `json:\"ologyMap\"`"
            - "\t\tSoongTypeList    [][]byte             `json:\"soongTypeList\"`"
            - "\t\tSoongTypeMap     map[string][]byte    `json:\"soongTypeMap\"`"
            - "\t\tTravellingList   []time.Time          `json:\"travellingList\"`"
            - "\t\tTravellingMap    map[string]time.Time `json:\"travellingMap\"`"
            - "\t\tTruthOrDareList  []bool               `json:\"truthOrDareList\"`"
            - "\t\tTruthOrDareMap   map[string]bool      `json:\"truthOrDareMap\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.EllijList = (inobj.EllijList)"
            - "\tobj.EllijMap = (inobj.EllijMap)"
            - "\tobj.EspressoList = (inobj.EspressoList)"
            - "\tobj.EspressoMap = (inobj.EspressoMap)"
            - "\tobj.IngCastleList = (inobj.IngCastleList)"
            - "\tobj.IngCastleMap = (inobj.IngCastleMap)"
            - "\tobj.IslandList = (inobj.IslandList)"
            - "\tobj.IslandMap = (inobj.IslandMap)"
            - "\tobj.OfCharactersList = (inobj.OfCharactersList)"
            - "\tobj.OfCharactersMap = (inobj.OfCharactersMap)"
            - "\tobj.OlogyList = (inobj.OlogyList)"
            - "\tobj.OlogyMap = (inobj.OlogyMap)"
            - "\tobj.SoongTypeList = (inobj.SoongTypeList)"
            - "\tobj.SoongTypeMap = (inobj.SoongTypeMap)"
            - "\tobj.TravellingList = (inobj.TravellingList)"
            - "\tobj.TravellingMap = (inobj.TravellingMap)"
            - "\tobj.TruthOrDareList = (inobj.TruthOrDareList)"
            - "\tobj.TruthOrDareMap = (inobj.TruthOrDareMap)"
            - "\treturn nil"
            - '}'
            - ""
            - type Things struct {
            - "\tEllij        int       `json:\"ellij\" yaml:\"ellij\" db:\"ellij\"`"
            - "\tEspresso     float64   `json:\"espresso\" yaml:\"espresso\" db:\"espresso\"`"
            - "\tIngCastle    float32   `json:\"ingCastle\" yaml:\"ingCastle\" db:\"ing_castle\"`"
            - "\tIsland       int64     `json:\"island\" yaml:\"island\" db:\"island\"`"
            - "\tOfCharacters string    `json:\"ofCharacters\" yaml:\"ofCharacters\"
              db:\"of_characters\"`"
            - "\tOlogy        struct{}  `json:\"ology\" yaml:\"ology\" db:\"ology\"`"
            - "\tSoongType    []byte    `json:\"soongType\" yaml:\"soongType\" db:\"soong_type\"`"
            - "\tTravelling   time.Time `json:\"travelling\" yaml:\"travelling\" db:\"travelling\"`"
            - "\tTruthOrDare  bool      `json:\"truthOrDare\" yaml:\"truthOrDare\"
              db:\"truth_or_dare\"`"
            - '}'
            - ""
            - func (obj *Things) MarshalJSON() ([]byte, error) {
            - "\toutobj := struct {"
            - "\t\tEllij        int      `json:\"ellij\"`"
            - "\t\tEspresso     float64  `json:\"espresso\"`"
            - "\t\tIngCastle    float32  `json:\"ingCastle\"`"
            - "\t\tIsland       int64    `json:\"island\"`"
            - "\t\tOfCharacters string   `json:\"ofCharacters\"`"
            - "\t\tOlogy        struct{} `json:\"ology\"`"
            - "\t\tSoongType    []byte   `json:\"soongType\"`"
            - "\t\tTravelling   float64  `json:\"travelling\"`"
            - "\t\tTruthOrDare  bool     `json:\"truthOrDare\"`"
            - "\t}{"
            - "\t\tEllij:        (obj.Ellij),"
            - "\t\tEspresso:     (obj.Espresso),"
            - "\t\tIngCastle:    (obj.IngCastle),"
            - "\t\tIsland:       (obj.Island),"
            - "\t\tOfCharacters: (obj.OfCharacters),"
            - "\t\tOlogy:        (obj.Ology),"
            - "\t\tSoongType:    (obj.SoongType),"
            - "\t\tTravelling: (func(t time.Time) float64 {"
            - "\t\t\tsec, nsec := t.Unix(), t.Nanosecond()"
            - "\t\t\treturn float64(sec) + (float64(nsec) / float64(time.Second))"
            - "\t\t})(obj.Travelling),"
            - "\t\tTruthOrDare: (obj.TruthOrDare),"
            - "\t}"
            - "\treturn json.Marshal(outobj)"
            - '}'
            - ""
            - func (obj *Things) UnmarshalJSON(buf []byte) error {
            - "\tinobj := struct {"
            - "\t\tEllij        int      `json:\"ellij\"`"
            - "\t\tEspresso     float64  `json:\"espresso\"`"
            - "\t\tIngCastle    float32  `json:\"ingCastle\"`"
            - "\t\tIsland       int64    `json:\"island\"`"
            - "\t\tOfCharacters string   `json:\"ofCharacters\"`"
            - "\t\tOlogy        struct{} `json:\"ology\"`"
            - "\t\tSoongType    []byte   `json:\"soongType\"`"
            - "\t\tTravelling   float64  `json:\"travelling\"`"
            - "\t\tTruthOrDare  bool     `json:\"truthOrDare\"`"
            - "\t}{}"
            - ""
            - "\tif err := json.Unmarshal(buf, &inobj); err != nil {"
            - "\t\treturn err"
            - "\t}"
            - ""
            - "\tobj.Ellij = (inobj.Ellij)"
            - "\tobj.Espresso = (inobj.Espresso)"
            - "\tobj.IngCastle = (inobj.IngCastle)"
            - "\tobj.Island = (inobj.Island)"
            - "\tobj.OfCharacters = (inobj.OfCharacters)"
            - "\tobj.Ology = (inobj.Ology)"
            - "\tobj.SoongType = (inobj.SoongType)"
            - "\tobj.Travelling = (func(t float64) time.Time {"
            - "\t\tfsec, fnsec := math.Modf(t)"
            - "\t\tsec, nsec := int64(fsec), int64(math.Round(fnsec*float64(time.Second)))"
            - "\t\treturn time.Unix(sec, nsec)"
            - "\t})(inobj.Travelling)"
            - "\tobj.TruthOrDare = (inobj.TruthOrDare)"
            - "\treturn nil"
            - '}'
            - ""
            - type Enums string
            - ""
            - const (
            - "\tEnumsThe   = Enums(\"the\")"
            - "\tEnumsQuick = Enums(\"quick\")"
            - "\tEnumsBrown = Enums(\"brown\")"
            - "\tEnumsFox   = Enums(\"fox\")"
            - "\tEnumsJumps = Enums(\"jumps\")"
            - "\tEnumsOver  = Enums(\"over\")"
            - "\tEnumsThe   = Enums(\"the\")"
            - "\tEnumsLazy  = Enums(\"lazy\")"
            - "\tEnumsDog   = Enums(\"dog\")"
            - )
            - ""
            - type Interface interface {
            - "\tAllThe(context.Context, *Things) (*Things, error,"
            - "\t)"
            - "\tCatIn(context.Context, *Containers) (*Containers, error,"
            - "\t)"
            - "\tMixEmUp(context.Context, *Things, *Containers, []*Things) (struct{},
              error,"
            - "\t)"
            - '}'
            - '-----END rpc.go-----'
            - ""
        - name: /tmp/rpc/go/*/*.go
          data:
            - '-----BEGIN client.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: go.example.com/rpc/client'
            - package client
            - ""
            - import (
            - "\t\"bytes\""
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"net/http\""
            - "\t\"time\""
            - ""
            - "\trpc_root \"go.example.com/rpc\""
            - )
            - ""
            - var (
            - "\t_ context.Context = nil"
            - "\t_ time.Time       = time.Time{}"
            - )
            - ""
            - // go.example.com/rpc
            - var _ rpc_root.Interface = Client_rpc_root{}
            - ""
            - type Client_rpc_root struct {
            - "\t*Client"
            - '}'
            - ""
            - func (c *Client_rpc_root) initialize(client *Client) {
            - "\tc.Client = client"
            - '}'
            - ""
            - func (c Client_rpc_root) AllThe(
            - "\tctx context.Context,"
            - "\targ0 *rpc_root.Things,"
            - ) (
            - "\tout0 *rpc_root.Things,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/rpc/AllThe\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_root) CatIn(
            - "\tctx context.Context,"
            - "\targ0 *rpc_root.Containers,"
            - ) (
            - "\tout0 *rpc_root.Containers,"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/rpc/CatIn\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - func (c Client_rpc_root) MixEmUp(
            - "\tctx context.Context,"
            - "\targ0 *rpc_root.Things,"
            - "\targ1 *rpc_root.Containers,"
            - "\targ2 []*rpc_root.Things,"
            - ) (
            - "\tout0 struct{},"
            - "\terr error,"
            - ) {
            - "\tpayload := []interface{}{arg0, arg1, arg2}"
            - ""
            - "\tbuf := &bytes.Buffer{}"
            - "\tif err = json.NewEncoder(buf).Encode(payload); err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\tvar req *http.Request"
            - "\treq, err = http.NewRequest(\"POST\", \"http://\"+c.Client.Options.Addr+\"/rpc/MixEmUp\",
              buf)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treq = req.WithContext(ctx)"
            - ""
            - "\tvar resp *http.Response"
            - "\tresp, err = c.HTTPClient.Do(req)"
            - "\tif err != nil {"
            - "\t\treturn"
            - "\t}"
            - ""
            - "\treturns := [1]interface{}{&out0}"
            - "\tresult := &Result{}"
            - "\tresult.Returns = returns[:]"
            - ""
            - "\tif resp.Body != nil {"
            - "\t\tdefer resp.Body.Close()"
            - ""
            - "\t\tif err = json.NewDecoder(resp.Body).Decode(result); err != nil
              {"
            - "\t\t\treturn"
            - "\t\t}"
            - "\t}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\terr = result.Error"
            - "\t}"
            - "\treturn"
            - '}'
            - ""
            - type Result struct {
            - "\tError   error         `json:\"error\"`"
            - "\tReturns []interface{} `json:\"returns\"`"
            - '}'
            - ""
            - type Client struct {
            - "\tOptions"
            - "\tClient_rpc_root"
            - ""
            - "\tHTTPClient *http.Client"
            - '}'
            - ""
            - type Options struct {
            - "\tAddr string"
            - '}'
            - ""
            - func New(opts *Options) *Client {
            - "\tclient := &Client{"
            - "\t\tOptions:         *opts,"
            - "\t\tClient_rpc_root: Client_rpc_root{},"
            - "\t\tHTTPClient:      &http.Client{},"
            - "\t}"
            - "\tclient.Client_rpc_root.initialize(client)"
            - "\treturn client"
            - '}'
            - '-----END client.go-----'
            - ""
            - '-----BEGIN server.go-----'
            - // <auto-generated />
            - // @generated by github.com/chakrit/rpc
            - //
            - '// expected import: go.example.com/rpc/server'
            - package server
            - ""
            - import (
            - "\t\"context\""
            - "\t\"encoding/json\""
            - "\t\"net/http\""
            - ""
            - "\trpc_root \"go.example.com/rpc\""
            - )
            - ""
            - type Provider_rpc_root interface {
            - "\tProvide_rpc_root() rpc_root.Interface"
            - '}'
            - ""
            - type Result struct {
            - "\tError   error         `json:\"error\"`"
            - "\tReturns []interface{} `json:\"returns\"`"
            - '}'
            - ""
            - type Server struct {
            - "\toptions  Options"
            - "\tProvider Provider_rpc_root"
            - '}'
            - ""
            - type Options struct {
            - "\tAddr      string"
            - "\tCtxFilter func(req *http.Request, method string) context.Context"
            - "\tErrFilter func(req *http.Request, method string, err error) error"
            - "\tErrLog    func(req *http.Request, method string, err error)"
            - "\tFormatErr func(err error) string"
            - '}'
            - ""
            - func New(opts *Options) *Server {
            - "\tsrv := &Server{options: *opts}"
            - "\tif srv.options.CtxFilter == nil {"
            - "\t\tsrv.options.CtxFilter = func(req *http.Request, _ string) context.Context
              {"
            - "\t\t\treturn req.Context()"
            - "\t\t}"
            - "\t}"
            - "\tif srv.options.ErrFilter == nil {"
            - "\t\tsrv.options.ErrFilter = func(_ *http.Request, _ string, err error)
              error {"
            - "\t\t\treturn err"
            - "\t\t}"
            - "\t}"
            - "\treturn srv"
            - '}'
            - ""
            - func (s *Server) Listen() error {
            - "\treturn http.ListenAndServe(s.options.Addr, s.HTTPHandler())"
            - '}'
            - ""
            - func (s *Server) HTTPHandler() http.Handler {
            - "\tmux := http.NewServeMux()"
            - "\ts.register_rpc_root(mux, s.Provider)"
            - "\treturn mux"
            - '}'
            - ""
            - func (s *Server) register_rpc_root(
            - "\tmux *http.ServeMux,"
            - "\tprovider Provider_rpc_root,"
            - ) *http.ServeMux {
            - "\thandler := provider.Provide_rpc_root()"
            - ""
            - "\tmux.HandleFunc(\"/rpc/AllThe\", func(resp http.ResponseWriter, req
              *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"rpc/AllThe\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 *rpc_root.Things"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_root.Things"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.AllThe("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"rpc/AllThe\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"rpc/AllThe\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/rpc/CatIn\", func(resp http.ResponseWriter, req
              *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"rpc/CatIn\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 *rpc_root.Containers"
            - "\t\targs := [1]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 *rpc_root.Containers"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.CatIn("
            - "\t\t\tctx, arg0)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"rpc/CatIn\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"rpc/CatIn\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\tmux.HandleFunc(\"/rpc/MixEmUp\", func(resp http.ResponseWriter, req
              *http.Request) {"
            - "\t\tvar ("
            - "\t\t\terr error"
            - "\t\t\tctx context.Context"
            - "\t\t)"
            - ""
            - "\t\tctx = s.options.CtxFilter(req, \"rpc/MixEmUp\")"
            - "\t\treq = req.WithContext(ctx)"
            - ""
            - "\t\tvar arg0 *rpc_root.Things"
            - "\t\tvar arg1 *rpc_root.Containers"
            - "\t\tvar arg2 []*rpc_root.Things"
            - "\t\targs := [3]interface{}{"
            - "\t\t\t&arg0,"
            - "\t\t\t&arg1,"
            - "\t\t\t&arg2,"
            - "\t\t}"
            - ""
            - "\t\tif req.Body != nil {"
            - "\t\t\tif err := json.NewDecoder(req.Body).Decode(&args); err != nil
              {"
            - "\t\t\t\trenderResult(s.options, resp, 400, &Result{"
            - "\t\t\t\t\tError:   err,"
            - "\t\t\t\t\tReturns: nil,"
            - "\t\t\t\t})"
            - "\t\t\t\treturn"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\tvar ("
            - "\t\t\tout0 struct{}"
            - "\t\t)"
            - ""
            - "\t\tout0, err = handler.MixEmUp("
            - "\t\t\tctx, arg0, arg1, arg2)"
            - ""
            - "\t\tresult := &Result{}"
            - "\t\tif err != nil {"
            - "\t\t\terr = s.options.ErrFilter(req, \"rpc/MixEmUp\", err)"
            - "\t\t\tif s.options.ErrLog != nil {"
            - "\t\t\t\ts.options.ErrLog(req, \"rpc/MixEmUp\", err)"
            - "\t\t\t}"
            - "\t\t\tresult.Error = err"
            - "\t\t} else {"
            - "\t\t\tresult.Returns = []interface{}{"
            - "\t\t\t\tout0,"
            - "\t\t\t}"
            - "\t\t}"
            - ""
            - "\t\trenderResult(s.options, resp, 200, result)"
            - "\t})"
            - ""
            - "\treturn mux"
            - '}'
            - ""
            - func renderResult(options Options, resp http.ResponseWriter, status
              int, result *Result) {
            - "\tresp.Header().Set(\"Content-Type\", \"application/json\")"
            - ""
            - "\tshim := struct {"
            - "\t\tError   *string       `json:\"error\"`"
            - "\t\tReturns []interface{} `json:\"returns\"`"
            - "\t}{}"
            - ""
            - "\tif result.Error != nil {"
            - "\t\tvar errstr string"
            - "\t\tif options.FormatErr != nil {"
            - "\t\t\terrstr = options.FormatErr(result.Error)"
            - "\t\t} else {"
            - "\t\t\terrstr = result.Error.Error()"
            - "\t\t}"
            - ""
            - "\t\tshim.Returns, shim.Error = nil, &errstr"
            - ""
            - "\t} else {"
            - "\t\tshim.Returns, shim.Error = result.Returns, nil"
            - "\t}"
            - ""
            - "\tbuf, err := json.Marshal(shim)"
            - "\tif err != nil {"
            - "\t\tresp.WriteHeader(500)"
            - "\t\t_, _ = resp.Write([]byte(`{\"error\":\"json processing error\",\"result\":null}`))"
            - "\t} else {"
            - "\t\tresp.WriteHeader(status)"
            - "\t\t_, _ = resp.Write(buf)"
            - "\t}"
            - '}'
            - '-----END server.go-----'
            - ""
        - name: /tmp/rpc/go/*/*/*.go
          data: []
- name: ./smoketests.yml \ Client<->Server \ Go
  commands:
    - command: go generate -v ./...
      checks:
        - name: exitcode
          data:
            - "0"
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - handler.go
            - main.go
            - api/rpc.go
            - api/client/client.go
            - api/server/server.go
    - command: go build -o ./bin/clientserver .
      checks:
        - name: exitcode
          data:
            - "0"
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - ""
        - name: stderr
          data:
            - ""
    - command: ./bin/clientserver
      checks:
        - name: exitcode
          data:
            - "0"
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - List
            - Update
            - '[alpha] alpha'
            - Update
            - '[beta] beta !DONE!'
            - List
            - '[alpha] alpha'
            - '[beta] beta !DONE!'
            - Destroy
            - '[alpha] alpha'
            - Destroy
            - '[beta] beta !DONE!'
            - List
        - name: stderr
          data:
            - ""
- name: ./smoketests.yml \ Examples \ todoapp
  commands:
    - command: ./build.sh
      checks:
        - name: exitcode
          data:
            - "0"
        - name: exitcode
          data:
            - "0"
        - name: stdout
          data:
            - "Compiling ...\rCompiling (1)\rCompiling (2)\rSuccess! Compiled 2 modules."
            - ""
            - '    Main > index.html'
        - name: stderr
          data:
            - ""
